<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://froldh.github.io</id>
    <title>寒鸽儿のBlog</title>
    <updated>2020-08-02T14:29:30.367Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://froldh.github.io"/>
    <link rel="self" href="https://froldh.github.io/atom.xml"/>
    <subtitle>寒鸽儿gugugu~</subtitle>
    <logo>https://froldh.github.io/images/avatar.png</logo>
    <icon>https://froldh.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, 寒鸽儿のBlog</rights>
    <entry>
        <title type="html"><![CDATA[STL备忘录]]></title>
        <id>https://froldh.github.io/post/stl-bei-wang-lu/</id>
        <link href="https://froldh.github.io/post/stl-bei-wang-lu/">
        </link>
        <updated>2020-08-02T12:19:11.000Z</updated>
        <summary type="html"><![CDATA[<p>有些STL里的东西总是要忘记 , 故而开个坑 , 用到的时候存一下 , 随缘更新。</p>
]]></summary>
        <content type="html"><![CDATA[<p>有些STL里的东西总是要忘记 , 故而开个坑 , 用到的时候存一下 , 随缘更新。</p>
<!-- more -->
<h2 id="有序序列操作">有序序列操作</h2>
<h3 id="二分">二分</h3>
<pre><code>ForwardIterator lower_bound(ForwardIterator _First, ForwardIterator _Last, const Type&amp; _Val, BinaryPredicate _Comp)
ForwardIterator upper_bound(ForwardIterator _First, ForwardIterator _Last, const Type&amp; _Val, BinaryPredicate _Comp)
Boolean binary_search(ForwardIterator _First, ForwardIterator _Last, const Type&amp; _Val, BinaryPredicate _Comp)
</code></pre>
<p><code>binary_search()</code>返回 <code>true/false</code> 表示 <code>能/不能</code> 搜到某个值 , 基本上用不到。</p>
<p>讨论 <code>lower_bound()</code> 和 <code>upper_bound()</code> 。</p>
<p>前三个为必选参数。<code>_First</code> 和 <code>_Last</code> 两个迭代器指定了查询区间。 <code>_Val</code> 指定了查询的量。 <code>_Comp</code> 为比较器(可选参数)。</p>
<p>在 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>[</mo><mi mathvariant="normal">_</mi><mi>F</mi><mi>i</mi><mi>r</mi><mi>s</mi><mi>t</mi><mo separator="true">,</mo><mi mathvariant="normal">_</mi><mi>L</mi><mi>a</mi><mi>s</mi><mi>t</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">[\_First, \_Last)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.06em;vertical-align:-0.31em;"></span><span class="mopen">[</span><span class="mord" style="margin-right:0.02778em;">_</span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord" style="margin-right:0.02778em;">_</span><span class="mord mathdefault">L</span><span class="mord mathdefault">a</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mclose">)</span></span></span></span> 区间中查找。<code>lower_bound</code>表示可以取等。upper_bound表示严格大于/小于。</p>
<p>第四个参数默认的情况下 , <strong>原区间需已经按照升序排列</strong>。<code>lower_bound()</code>查找第一个 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>⩾</mo><mi>k</mi><mi>e</mi><mi>y</mi></mrow><annotation encoding="application/x-tex">\geqslant key</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7733399999999999em;vertical-align:-0.13667em;"></span><span class="mrel amsrm">⩾</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span> 的元素并返回其迭代器 , 如果找不到(即全部[first, last)中的元素 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>&lt;</mo><mi>k</mi><mi>e</mi><mi>y</mi></mrow><annotation encoding="application/x-tex">&lt;key</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span> ) 则 <code>return _Last</code>。<code>upper_bound()</code> 查找第一个 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>&gt;</mo><mi>k</mi><mi>e</mi><mi>y</mi></mrow><annotation encoding="application/x-tex">&gt;key</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span> 的元素并返回其迭代器 , 找不到则<code>return _Last</code>。</p>
<p>(以下所提及的&quot;第一个&quot;定义为在不满足条件的元素和满足条件的元素交界处的满足条件的元素)。</p>
<p>若在<strong>降序区间</strong>查找第一个 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>⩾</mo></mrow><annotation encoding="application/x-tex">\geqslant</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7733399999999999em;vertical-align:-0.13667em;"></span><span class="mrel amsrm">⩾</span></span></span></span> 或者 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>&gt;</mo></mrow><annotation encoding="application/x-tex">&gt;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">&gt;</span></span></span></span> 则需要传入一个反序的比较器。例如 <code>greater&lt;Type&gt;()</code> 。相当于重新定义了大小关系。</p>
<p>若在<strong>升序区间</strong>查找第一个 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>⩽</mo></mrow><annotation encoding="application/x-tex">\leqslant</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7733399999999999em;vertical-align:-0.13667em;"></span><span class="mrel amsrm">⩽</span></span></span></span> 或者 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>&lt;</mo></mrow><annotation encoding="application/x-tex">&lt;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">&lt;</span></span></span></span> , 同样可以传入反序比较器重新定义大小关系。</p>
<p>(具体的可以画图  <code>greater&lt;Type&gt;()</code> 相当于把图中走向取反来推 , 记住第一个是分界处的元素)。</p>
<p><strong>总结</strong> :</p>
<ol>
<li>两者的区别在于等号(lower取等)。</li>
<li>默认 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>&gt;</mo><mi mathvariant="normal">/</mi><mo>⩾</mo></mrow><annotation encoding="application/x-tex">&gt; / \geqslant</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">/</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel amsrm">⩾</span></span></span></span> 。</li>
<li><code>greater&lt;type&gt;()</code> 调成小于。</li>
<li>返回指针(需要减去头指针得到下标) , 找不到<code>return last</code>。</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[2020-08-02训练日记]]></title>
        <id>https://froldh.github.io/post/2020-08-02-xun-lian-ri-ji/</id>
        <link href="https://froldh.github.io/post/2020-08-02-xun-lian-ri-ji/">
        </link>
        <updated>2020-08-02T08:11:44.000Z</updated>
        <summary type="html"><![CDATA[<h1 id="前情提要">前情提要</h1>
<p>填完志愿 , 尘埃落定。</p>
<h1 id="view">View</h1>
<ol>
<li><a href="https://www.luogu.com.cn/problem/P3919">LG3919 可持久化数组(可持久化线段树板子)</a></li>
<li><a href="https://www.luogu.com.cn/problem/P3834">LG3834 区间第k大值(可持久化权值线段树板子)</a></li>
<li><a href="https://www.luogu.com.cn/problem/P3567">[POI2014]KUR-Couriers</a></li>
</ol>
]]></summary>
        <content type="html"><![CDATA[<h1 id="前情提要">前情提要</h1>
<p>填完志愿 , 尘埃落定。</p>
<h1 id="view">View</h1>
<ol>
<li><a href="https://www.luogu.com.cn/problem/P3919">LG3919 可持久化数组(可持久化线段树板子)</a></li>
<li><a href="https://www.luogu.com.cn/problem/P3834">LG3834 区间第k大值(可持久化权值线段树板子)</a></li>
<li><a href="https://www.luogu.com.cn/problem/P3567">[POI2014]KUR-Couriers</a></li>
</ol>
<!-- more -->
<h1 id="detail">Detail</h1>
<h2 id="可持久化线段树">可持久化线段树</h2>
<h3 id="note">Note</h3>
<h4 id="思想">思想</h4>
<p>实际上就是用线段树维护了一个数组 , 然后对修改在线段树上执行可持久化的操作。</p>
<p>特殊地 , 在可持久化数组的实现中 , 用到线段树本身的性质只有naive的(单点查询/单点修改)。因而非叶子节点的data域可以不用维护数据。当然 , 线段树维护数组数据时可以简单维护的数组信息如区间最大值、区间和等一样可以可持久化。</p>
<p>可持久化针对单点修改操作 , 实际上修改掉的就是一条链。将这条由根到叶子的链复制出来进行修改 , 并返回新的根 , 就可以通过这个新的根来访问这个版本的信息(那些不变的部分由其父亲复制出来的新版本的节点直接指向从而实现了空间的节省)。</p>
<pre><code class="language-cpp">void insert(int &amp;p, int rec, int lp, int rp, int x, int v) {
	p = tot++; ls[p] = ls[rec], rs[p] = rs[rec], dat[p] = dat[rec];     //将要修改的链上的节点rec复制一份作为当前树的节点。
	if(lp == rp) { dat[p] = v; return; }    //对叶子节点做修改
	int mid = (lp + rp) &gt;&gt; 1;
    //递归处理要修改的链上当前点的后继
	if(x &lt;= mid) insert(ls[p], ls[rec], lp, mid, x, v);
	else insert(rs[p], rs[rec], mid + 1, rp, x, v);
    //如果需要用线段树维护信息 , 这里还要加上update(p)
}
</code></pre>
<h4 id="空间大小的计算对于普通的可持久化线段树-对长度为-mathcaln-的序列建树并做-m-次修改">空间大小的计算(对于普通的可持久化线段树 , 对长度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">\mathcal{n}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">n</span></span></span></span></span> 的序列建树并做 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span> 次修改) :</h4>
<p>由二叉树的性质 , 线段树树高上界(即链长上界)为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>⌈</mo><msub><mi>log</mi><mo>⁡</mo><mn>2</mn></msub><mi>m</mi><mi>a</mi><mi>x</mi><mi>n</mi><mo>⌉</mo><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\lceil \log _2 maxn \rceil + 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">⌈</span><span class="mop"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.20696799999999996em;"><span style="top:-2.4558600000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.24414em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mord mathdefault">n</span><span class="mclose">⌉</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 个结点空间大小。树中结点个数的上界为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mrow><mo>⌈</mo><msub><mi>log</mi><mo>⁡</mo><mn>2</mn></msub><mi>m</mi><mi>a</mi><mi>x</mi><mi>n</mi><mo>⌉</mo><mo>+</mo><mn>1</mn></mrow></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2^{\lceil \log _2 maxn \rceil + 1} - 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9713299999999999em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8879999999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">⌈</span><span class="mop mtight"><span class="mop mtight">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.19444571428571428em;"><span style="top:-2.2341314285714287em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.26586857142857145em;"><span></span></span></span></span></span></span><span class="mspace mtight" style="margin-right:0.19516666666666668em;"></span><span class="mord mathdefault mtight">m</span><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight">x</span><span class="mord mathdefault mtight">n</span><span class="mclose mtight">⌉</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 。</p>
<p><strong>建树</strong>过程中 , 确切空间花销上界为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mrow><mo>⌈</mo><msub><mi>log</mi><mo>⁡</mo><mn>2</mn></msub><mi>m</mi><mi>a</mi><mi>x</mi><mi>n</mi><mo>⌉</mo><mo>+</mo><mn>1</mn></mrow></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2^{\lceil \log _2 maxn \rceil + 1} - 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9713299999999999em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8879999999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">⌈</span><span class="mop mtight"><span class="mop mtight">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.19444571428571428em;"><span style="top:-2.2341314285714287em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.26586857142857145em;"><span></span></span></span></span></span></span><span class="mspace mtight" style="margin-right:0.19516666666666668em;"></span><span class="mord mathdefault mtight">m</span><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight">x</span><span class="mord mathdefault mtight">n</span><span class="mclose mtight">⌉</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 个结点空间大小。</p>
<p><strong>修改</strong>过程中 , 观察每次修改实际上就是复制了一条链 , 空间花销等于链所占的空间 , 故单次修改的空间上界即为链长上界 。 则 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span>次修改的空间总花销上界为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi><mo>(</mo><mo>⌈</mo><msub><mi>log</mi><mo>⁡</mo><mn>2</mn></msub><mi>m</mi><mi>a</mi><mi>x</mi><mi>n</mi><mo>⌉</mo><mo>+</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">m(\lceil \log _2 maxn \rceil + 1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mopen">(</span><span class="mopen">⌈</span><span class="mop"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.20696799999999996em;"><span style="top:-2.4558600000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.24414em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mord mathdefault">n</span><span class="mclose">⌉</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span> 个结点空间大小。</p>
<p>总共的空间开销上界为(单位 : 结点空间大小)</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mrow><mo>⌈</mo><msub><mi>log</mi><mo>⁡</mo><mn>2</mn></msub><mi>m</mi><mi>a</mi><mi>x</mi><mi>n</mi><mo>⌉</mo><mo>+</mo><mn>1</mn></mrow></msup><mo>+</mo><mi>m</mi><mo>(</mo><mo>⌈</mo><msub><mi>log</mi><mo>⁡</mo><mn>2</mn></msub><mi>m</mi><mi>a</mi><mi>x</mi><mi>n</mi><mo>⌉</mo><mo>+</mo><mn>1</mn><mo>)</mo><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2^{\lceil \log _2 maxn \rceil + 1} + m(\lceil \log _2 maxn \rceil + 1) - 1
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0213299999999998em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9379999999999998em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">⌈</span><span class="mop mtight"><span class="mop mtight">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.19444571428571428em;"><span style="top:-2.2341314285714287em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.26586857142857145em;"><span></span></span></span></span></span></span><span class="mspace mtight" style="margin-right:0.19516666666666668em;"></span><span class="mord mathdefault mtight">m</span><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight">x</span><span class="mord mathdefault mtight">n</span><span class="mclose mtight">⌉</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mopen">(</span><span class="mopen">⌈</span><span class="mop"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.20696799999999996em;"><span style="top:-2.4558600000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.24414em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mord mathdefault">n</span><span class="mclose">⌉</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></span></p>
<p>具体做题时可以直接拿来算( 先算出满足 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mi>k</mi></msup><mo>⩾</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">2^k \geqslant n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.985778em;vertical-align:-0.13667em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel amsrm">⩾</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 的最小的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span> )。</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo></mrow><annotation encoding="application/x-tex">\mathcal(</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span></span></span></span> i.e. 空间复杂度为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="script">O</mi><mo>(</mo><mi>n</mi><mo>+</mo><mi>m</mi><mtext> </mtext><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O(n + m\ log n)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">m</span><span class="mspace"> </span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></span> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>)</mo></mrow><annotation encoding="application/x-tex">\mathcal)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mclose">)</span></span></span></span></p>
<h4 id="区间修改引发的问题及两种解决方式">区间修改引发的问题及两种解决方式</h4>
<p>在进行可持久化线段树维护区间修改的时候 , 注意不能直接下放标记。因为在修改时可能出现下放标记到的点被其他的版本共用。解决的一个方案是将要被下放到待修改的点复制一遍然后对复制出来的点做修改并作为这个版本的新点 , 这样的坏处是空间利用率非常低很容易MLE。另一种策略是标记永久化 , 但这样做的局限是要下放的标记是相对标记(区间加减是相对标记 , 区间赋值是绝对标记)???</p>
<p>特殊地 , 对于刚开始为空的树不用进行build操作(想想性质)。</p>
<h4 id="可持久化权值线段树">可持久化权值线段树</h4>
<p>对权值线段树进行可持久化 , 可以得到不同历史版本的区间上的权值信息。</p>
<h5 id="维护任意区间">维护任意区间</h5>
<p>把序列下标顺序作为时间轴 , 按照序列递进作为时间演进顺序 , 可以得到所有前缀序列<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>[</mo><mn>1</mn><mo separator="true">,</mo><mi>i</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">[1, i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">i</span><span class="mclose">]</span></span></span></span>的权值和信息。具体地 , 从左向右扫一便序列 , 每次插入1个值 , 当前版本即为区间<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>[</mo><mn>1</mn><mo separator="true">,</mo><mi>i</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">[1,i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">i</span><span class="mclose">]</span></span></span></span>的权值信息。</p>
<p>由于区间权值个数支持第三维上的区间减 , 故而可以用差分的思想利用前缀和之差在可持久化权值树上查询任意一段区间的权值信息(用r版本的个数减去l-1版本的个数得到区间 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>[</mo><mi>l</mi><mo separator="true">,</mo><mi>r</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">[l, r]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mclose">]</span></span></span></span> 上的权值信息)。</p>
<p>这可以用来高速求任意区间第 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span> 大值 , 任意区间众数等等。</p>
<p>实际思考中 , 在权值线段树维护的序列上能简单高效查询的信息几乎都可以用可持久化权值树利用前缀和 + 差分的思想支持任意区间快速查询。</p>
<h3 id="lg3919可持久化数组">LG3919可持久化数组</h3>
<p>可持久化数组使用可持久化线段树来维护 , 本题不需要用到线段树的其他性质。</p>
<h4 id="事项">事项</h4>
<ol>
<li>在insert下传时 , 不要忘记将原链上的点变为后继 , 即<code>insert(..., ls[pre], ...)</code>不要写成<code>insert(..., pre, ...)</code>。</li>
</ol>
<h4 id="code">Code</h4>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;

using namespace std;

const int maxs = 23000010, maxn = 1000010;

int dat[maxs], ls[maxs], rs[maxs], tot;
int vers[maxn];

inline void read(int &amp;x) {
	x = 0; int f = 1; char ch = getchar();
	while(ch &lt; '0' || ch &gt; '9') {if(ch == '-') f = -f; ch = getchar();}
	while(ch &gt;= '0' &amp;&amp; ch &lt;= '9') x = (x&lt;&lt;3) + (x&lt;&lt;1) + (ch&amp;15), ch = getchar();
	x *= f;
}

void build(int &amp;p, int lp, int rp) {
	p = tot++;
	if(lp == rp) { read(dat[p]); return; }
	int mid = (lp + rp) &gt;&gt; 1;
	build(ls[p], lp, mid);
	build(rs[p], mid + 1, rp);
}

void insert(int &amp;p, int rec, int lp, int rp, int x, int v) {
	p = tot++; ls[p] = ls[rec], rs[p] = rs[rec], dat[p] = dat[rec];
	if(lp == rp) { dat[p] = v; return; }
	int mid = (lp + rp) &gt;&gt; 1;
	if(x &lt;= mid) insert(ls[p], ls[rec], lp, mid, x, v);
	else insert(rs[p], rs[rec], mid + 1, rp, x, v);
}

int qry(int p, int lp, int rp, int x) {
		if(lp == rp) return dat[p];
	int mid = (lp + rp) &gt;&gt; 1;
	if(x &lt;= mid) return qry(ls[p], lp, mid, x);
	return qry(rs[p], mid + 1, rp, x);
}

int main() {
	int n, m;
	read(n); read(m);
	tot = 1;
	build(vers[0], 1, n);
	int v, op, loc, value;
	for(int vs = 1; vs &lt;= m; ++vs) {
		read(v); read(op); read(loc);
		if(op == 1) {
			read(value);
			insert(vers[vs], vers[v], 1, n, loc, value);
		} else {
			printf(&quot;%d\n&quot;,qry(vers[v], 1, n, loc));
			vers[vs] = vers[v];
		}
	}
	return 0;
}
</code></pre>
<h3 id="lg3834-区间第k大值可持久化权值线段树主席树解法">LG3834 区间第K大值(可持久化权值线段树(主席树)解法)</h3>
<h4 id="事项-2">事项</h4>
<ol>
<li>在开始扫原数组之前树是空的 , 并且可以不用建树(想一想性质 , 与动态开点线段树中往空树插第一个数据时的情形类似)。</li>
<li>可以使用动态开点线段树思想过掉本题(这样不用离散化) , 但是在某些值域更大的题目据说会MLE。(对于动态开点 , 一定不要去<code>build</code>(实际上非动态开点在本题中也不需要) , 然后直接下来就可以了 , 不用做更改 , 因为可持久化线段树的开点操作本来就是动态的 , 需要注意的是在负数内除以2下取整要用<code>lp + rp &gt;&gt; 1</code> , 不要使用 <code>(lp + rp) / 2</code>  , 它在负数情况中会向下取整)。</li>
</ol>
<h4 id="code-2">Code</h4>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;

using namespace std;

const int maxs = 4000010, maxn = 200010;
int dat[maxs], ls[maxs], rs[maxs], idx[maxn], tot;
int a[maxn], b[maxn];

inline void read(int &amp;x) {
	char ch; int f = 1; x = 0;
	do{ch = getchar(); if(ch == '-') f = -1;} while(ch &lt; '0' || ch &gt; '9');
	do{ x = (x&lt;&lt;3)+(x&lt;&lt;1)+(ch&amp;15), ch = getchar(); } while(ch &gt;= '0' &amp;&amp; ch &lt;= '9');
	x *= f;
}

int getbound(int l, int r, int xx) {
	while(l &lt; r) {
		int mid = (l + r) &gt;&gt; 1;
		if(b[mid] == xx) return mid;
		else if(b[mid] &gt; xx) r = mid - 1;
		else l = mid + 1;
	}
	return l;
}

void insert(int &amp;p, int pre, int lp, int rp, int x) {
	p = ++tot; ls[p] = ls[pre], rs[p] = rs[pre], dat[p] = dat[pre] + 1;
	if(lp == rp) return;
	int mid = (lp + rp) &gt;&gt; 1;
	if(x &lt;= mid) insert(ls[p], ls[pre], lp, mid, x);
	else insert(rs[p], rs[pre], mid + 1, rp, x);
}

int findkth(int r, int lol, int lp, int rp, int k) {
	if(lp == rp) return lp;
	int mid = (lp + rp) &gt;&gt; 1;
	if(k &lt;= dat[ls[r]] - dat[ls[lol]]) return findkth(ls[r], ls[lol], lp, mid, k);
	else return findkth(rs[r], rs[lol], mid + 1, rp, k - dat[ls[r]] + dat[ls[lol]]);
}

int main() {
	int n, m, l, r, k;
	read(n); read(m);
	for(int i = 1; i &lt;= n; ++i) {
		read(a[i]);
		b[i] = a[i];
	}
	sort(b + 1, b + n + 1);
	int nn = 1;
	for(int i = 2; i &lt;= n; ++i)
		if(b[i] != b[i-1])
			b[++nn] = b[i];
	tot = dat[0] = ls[0] = rs[0] =  idx[0] = 0;
	for(int i = 1; i &lt;= n; ++i)
		insert(idx[i], idx[i-1], 1, nn, getbound(1, nn, a[i]));	
	while(m--) {
		read(l); read(r); read(k);
		printf(&quot;%d\n&quot;, b[findkth(idx[r], idx[l - 1], 1, nn, k)]);
	}
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[一道听来的题目]]></title>
        <id>https://froldh.github.io/post/yi-dao-ting-lai-de-ti-mu/</id>
        <link href="https://froldh.github.io/post/yi-dao-ting-lai-de-ti-mu/">
        </link>
        <updated>2020-07-23T13:23:10.000Z</updated>
        <content type="html"><![CDATA[<p><img src="https://froldh.github.io/post-images/1595510681965.jpg" alt="" loading="lazy"><br>
思路 :<br>
<img src="https://froldh.github.io/post-images/1595511083324.png" alt="" loading="lazy"><br>
使用差分法 :<br>
对怪排序 ,  扫过去 , 同时统计当前有效的伤害值的总和(相当于一个求前缀和的过程) , 在扫到某个技能结束的地方总伤害-1。<br>
具体可以用two pointer或者维护技能与怪物两个栈实现。<br>
two pointer<br>
<img src="https://froldh.github.io/post-images/1595510961449.png" alt="" loading="lazy"><br>
栈<br>
<img src="https://froldh.github.io/post-images/1595511024902.png" alt="" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[2020-07-21~2020-07-22 训练日记]]></title>
        <id>https://froldh.github.io/post/2020-07-20~2020-07-21-xun-lian-ri-ji/</id>
        <link href="https://froldh.github.io/post/2020-07-20~2020-07-21-xun-lian-ri-ji/">
        </link>
        <updated>2020-07-20T15:28:58.000Z</updated>
        <summary type="html"><![CDATA[<h1 id="view">view</h1>
<ol>
<li>学习点分治 , 看了 几篇课件和《进阶指南》4.5 、XD7.15《图论课1》回放以及<a href="https://www.bilibili.com/video/BV1fE411w7RH?from=search&amp;seid=18170482803256782657">这个</a></li>
<li><a href="https://www.luogu.com.cn/problem/P3806">点分治板子</a></li>
<li><a href="https://www.luogu.com.cn/problem/P4178">LG4178</a></li>
<li><a href="https://www.luogu.com.cn/problem/CF161D">CF161D</a></li>
</ol>
]]></summary>
        <content type="html"><![CDATA[<h1 id="view">view</h1>
<ol>
<li>学习点分治 , 看了 几篇课件和《进阶指南》4.5 、XD7.15《图论课1》回放以及<a href="https://www.bilibili.com/video/BV1fE411w7RH?from=search&amp;seid=18170482803256782657">这个</a></li>
<li><a href="https://www.luogu.com.cn/problem/P3806">点分治板子</a></li>
<li><a href="https://www.luogu.com.cn/problem/P4178">LG4178</a></li>
<li><a href="https://www.luogu.com.cn/problem/CF161D">CF161D</a></li>
</ol>
<!-- more -->  
<h1 id="detail">detail</h1>
<h2 id="点分治">点分治</h2>
<h3 id="思想">思想</h3>
<p>一般用于做树上路径相关的统计。<br>
统计根的孩子中跨过根的路径 , 一般需要做到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="script">O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O(n)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></span> 或者 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="script">O</mi><mo>(</mo><mi>n</mi><mi>log</mi><mo>⁡</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O(n \log n)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></span> , 然后删掉根节点 , 递归统计各个子树的情况。<br>
根选择重心可以保证优秀的复杂度。</p>
<h3 id="处理方式">处理方式</h3>
<ol>
<li>点分治 --&gt; 考虑统计以根为lca的点对的情况。</li>
<li>处理可以把所有结点放在数组中排序然后two_pointer , 像莫队那样在移动指针的时候统计[l, r]之间的颜色数量。比较适用于求 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>⩽</mo><mi>k</mi></mrow><annotation encoding="application/x-tex">\leqslant k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7733399999999999em;vertical-align:-0.13667em;"></span><span class="mrel amsrm">⩽</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span> 或 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>⩾</mo><mi>k</mi></mrow><annotation encoding="application/x-tex">\geqslant k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7733399999999999em;vertical-align:-0.13667em;"></span><span class="mrel amsrm">⩾</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>  的节点对。</li>
<li>可以使用平衡树或者权值树来统计。对每棵子树依次calc-add。  用map可以方便地求 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>=</mo><mi>k</mi></mrow><annotation encoding="application/x-tex">=k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span> 的节点对。</li>
</ol>
<h2 id="lg点分治板子">LG点分治板子</h2>
<h3 id="事项">事项</h3>
<ol>
<li>work()函数(点分治主过程)用递归实现的效率高于用队列+循环实现。</li>
<li>用树状数组处理不应用memset , 而是将栈中的点对应的位置清零。(用memset复杂度会炸)</li>
<li>注意two_pointer的实现方式。</li>
</ol>
<h3 id="code">Code</h3>
<h4 id="递归实现12ms-156mb">递归实现(12ms , 1.56MB)</h4>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;

const int maxn = 12345, maxm = 123;

struct edge {
	int x, w;
	edge() { x = w = 0; }
	edge(int x, int w) : x(x), w(w) {}
};

typedef std::vector&lt;std::vector&lt; edge &gt; &gt; Graph;

Graph G;
int qry[maxm], q;
int siz[maxn];
int stk[maxn], top, fa[maxn];
int d[maxn], col[maxn];
bool del[maxn], ans[maxn];

void dfs1(int pre, int cur) {
	stk[top++] = cur; siz[cur] = 1;
	fa[cur] = pre;
	for(edge e : G[cur])
		if(!del[e.x] &amp;&amp; pre != e.x) {
			dfs1(cur, e.x);
			siz[cur] += siz[e.x];
		}
}

int find_root(int xx) {
	stk[0] = xx; top = 1;
	siz[xx] = 1;
	for(edge e : G[xx])
		if(!del[e.x]) {
			dfs1(xx, e.x);
			siz[xx] += siz[e.x];
		}
	for(int i = 0; i &lt; top; ++i)
		if(top - siz[stk[i]] &lt;= (top &gt;&gt; 1)) {
			bool flg = true;
			for(edge e : G[stk[i]])
				if(!del[e.x] &amp;&amp; e.x != fa[stk[i]] &amp;&amp; siz[e.x] &gt; (top &gt;&gt; 1)) {
					flg = false;
					break;
				}
			if(flg) return stk[i];
		}
}

void dfs2(int pre, int cur, int w, int color) {
	d[cur] = d[pre] + w;
	col[cur] = color;
	for(edge e : G[cur])
		if(!del[e.x] &amp;&amp; e.x != pre)
			dfs2(cur, e.x, e.w, color);
}

void work(int xx) {
	int rt = find_root(xx);
	if(top == 1) return;
	d[rt] = 0; col[rt] = 0;
	for(edge e : G[rt])
	 	if(!del[e.x])
			dfs2(rt, e.x, e.w, e.x);
	std::sort(stk, stk + top, [&amp;](int x, int y){ return d[x] &lt; d[y]; });
	for(int i = 0; i &lt; q; ++i) {
		if(ans[i]) continue;
		int l = 0, r = top - 1;
		while(l &lt; r) {
			if(d[stk[l]] + d[stk[r]] &lt; qry[i]) ++l;
			else if(d[stk[l]] + d[stk[r]] &gt; qry[i]) --r;
			else if(d[stk[l]] + d[stk[r]] == qry[i]) {
				if(col[stk[l]] != col[stk[r]]) {
					ans[i] = true;
					break;
				}
				if(d[stk[l + 1]] == d[stk[l]]) ++l;
				else --r;
			}
		}
	}
	del[rt] = true;
	for(edge e : G[rt])
		if(!del[e.x])
			work(e.x);
}

int main() {
	std::ios_base::sync_with_stdio(false);
	std::cin.tie(NULL);
	memset(del, false, sizeof(del));
	int n, u, v, w;
	std::cin &gt;&gt; n &gt;&gt; q;
	G.resize(n + 1);
	for(int i = 1; i &lt; n; ++i) {
		std::cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;
		G[u].push_back(edge(v, w));
		G[v].push_back(edge(u, w));
	}
	for(int i = 0; i &lt; q; ++i) std::cin &gt;&gt; qry[i];
	work(1);
	for(int i = 0; i &lt; q; ++i)
		if(ans[i])
			std::cout &lt;&lt; &quot;AYE\n&quot;;
		else
			std::cout &lt;&lt; &quot;NAY\n&quot;;
	return 0;
}
</code></pre>
<h4 id="队列-循环实现32ms-218mb">队列 + 循环实现(32ms , 2.18MB)</h4>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;

using namespace std;

const int maxn = 12345, maxm = 123;

struct edge {
	int x, w;
	edge() {}
	edge(int x, int w) : x(x), w(w) {} 
};
typedef vector&lt; vector&lt;edge&gt; &gt; graph;

graph G;
queue&lt;int&gt; q;
int qry[maxm], m;
int stk[maxn], top;
int siz[maxn], fa[maxn];
int d[maxn], col[maxn], ans[maxn];
bool del[maxn];

void dfs1(int pre, int cur) {
	stk[top++] = cur;
	siz[cur] = 1; fa[cur] = pre;
	for(edge e : G[cur])
		if(!del[e.x] &amp;&amp; e.x != pre)	 {
			dfs1(cur, e.x);
			siz[cur] += siz[e.x];
		}
}

int findroot(int xx) {
	top = 1;
	stk[0] = xx;
	siz[xx] = 1;
	for(edge e : G[xx]) 
		if(!del[e.x]) {
			dfs1(xx, e.x);
			siz[xx] += siz[e.x];
		}
	if(top == 1) return xx;
	for(int i = 0; i &lt; top; ++i) {
		int cur = stk[i];
		if(top - siz[cur] &gt; top / 2) continue;
		bool flg = true;
		for(edge e : G[cur]) 
			if(!del[e.x] &amp;&amp; e.x != fa[cur] &amp;&amp; siz[e.x] &gt; top / 2) {
				flg = false;
				break;
			}
		if(flg) return cur;
	}
}

void dfs2(int pre, int cur, int w, int color) {
	col[cur] = color;
	d[cur] = d[pre] + w;
	for(edge e : G[cur])
		if(!del[e.x] &amp;&amp; e.x != pre)
			dfs2(cur, e.x, e.w, color);
}

int main() {
	ios::sync_with_stdio(false);
	cin.tie(NULL);
	int n, u, v, w;
	cin &gt;&gt; n &gt;&gt; m;
	G.resize(n + 1);
	for(int i = 1; i &lt; n; ++i) {
		cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;
		G[u].push_back(edge(v, w));
		G[v].push_back(edge(u, w));
	}
	for(int i = 1; i &lt;= m; ++i) cin &gt;&gt; qry[i];
	q.push(1);
	while(!q.empty()) {
		int xx = q.front(); q.pop();
		int root = findroot(xx);
		if(top == 1) continue;
		d[root] = col[root] = 0;
		for(edge e : G[root])
			if(!del[e.x])
				dfs2(root, e.x, e.w, e.x);
		sort(stk, stk + top, [&amp;](int x, int y){ return d[x] &lt; d[y]; });
		for(int i = 1; i &lt;= m; ++i) {
			if(ans[i]) continue;
			int l = 0, r = top - 1; 
			while(l &lt; r) {
				if(d[stk[l]] + d[stk[r]] &lt; qry[i]) ++l;
				else if(d[stk[l]] + d[stk[r]] &gt; qry[i]) --r;
				else if(col[stk[l]] == col[stk[r]]) {
					if(d[stk[l]] == d[stk[l + 1]]) ++l;
					else --r;
				} else {
					ans[i] = true;
					break;
				}
			}
		}
		del[root] = true;
		for(edge e : G[root])
			if(!del[e.x])
				q.push(e.x);
	}
	for(int i = 1; i &lt;= m; ++i)
	if(ans[i])
		std::cout &lt;&lt; &quot;AYE\n&quot;;
	else
		std::cout &lt;&lt; &quot;NAY\n&quot;;
	return 0;	
}
</code></pre>
<h2 id="lg4178">LG4178</h2>
<h3 id="事项-2">事项</h3>
<ol>
<li>可用two_pointer解决 , 比较方便地求出点对数目(<code>R-L-num[col[L]]</code>)。</li>
</ol>
<h3 id="code-2">code</h3>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
#define endl '\n'
#define rep(i,a,b) for(int i=a;i&lt;=(b);++i)
#define per(i,a,b) for(int i=a;i&gt;=(b);--i)
#define repp(i,a,b) for(int i=a;i&lt;(b);++i)
#define perr(i,a,b) for(int i=a;i&gt;(b);--i)
#define pb push_back
#define rz resize
#define itra std::vector&lt;int&gt;::iterator;
#define VI vector&lt;int&gt;
#define VL vector&lt;long long&gt;
#define VD vector&lt;double&gt;

using namespace std;

typedef long long ll;
typedef pair&lt;int,int&gt; pii;

const int maxn = 56789;

struct edge {
	int x, w;
	edge() {}
	edge(int x, int w) : x(x), w(w) {}
};

typedef vector&lt; vector&lt;edge&gt; &gt; graph;
graph G;
long long ans = 0;
int k;
int stk[maxn], top;
int siz[maxn], fa[maxn];
int dis[maxn], col[maxn];
bool del[maxn];
int num[maxn];


void dfs1(int pre, int cur) {
	siz[cur] = 1; fa[cur] = pre;
	stk[top++] = cur;
	for(edge e : G[cur])
		if(e.x != pre &amp;&amp; !del[e.x]) {
			dfs1(cur, e.x);
			siz[cur] += siz[e.x];
		}
}

int findroot(int xx) {
	stk[0] = xx; top = 1;
	siz[xx] = 1;
	for(edge e : G[xx]) 
		if(!del[e.x]) {
			dfs1(xx, e.x);
			siz[xx] += siz[e.x];
		}
	for(int i = 0; i &lt; top; ++i) {
		int cur = stk[i];
		if(top - siz[cur] &gt; top / 2) continue;
		bool flg = true;
		for(edge e : G[cur])	
			if(!del[e.x] &amp;&amp; e.x != fa[cur] &amp;&amp; siz[e.x] &gt; top / 2) {
				flg = false; break;
			}
		if(flg) return cur;
	}
}

void dfs2(int pre, int cur, int wei, int color) {
	dis[cur] = dis[pre] + wei;
	col[cur] = color;
	for(edge e : G[cur])
		if(!del[e.x] &amp;&amp; e.x != pre)
			dfs2(cur, e.x, e.w, color);
}

long long calc(int k) {
	long long ans = 0;
	int l = 0, r = top - 1;
	for(int i = 1; i &lt; top; ++i) ++num[col[stk[i]]];
	for(; l &lt; r; --num[col[stk[++l]]]) {
		while(dis[stk[r]] + dis[stk[l]] &gt; k) {
			--num[col[stk[r]]]; --r;
		}
		if(r &gt; l)
			ans += r - l - num[col[stk[l]]];
	}
	for(int i = 0; i &lt; top; ++i) num[col[stk[i]]] = 0;
	return ans;
}

void work(int xx) {
	xx = findroot(xx);
	if(top == 1) return;
	col[xx] = dis[xx] = 0;
	for(edge e : G[xx])
		if(!del[e.x])
			dfs2(xx, e.x, e.w, e.x);
	sort(stk, stk + top, [&amp;](int x, int y){ return dis[x] &lt; dis[y]; });
	ans += calc(k);
	del[xx] = true;
	for(edge e : G[xx])
		if(!del[e.x])
			work(e.x);
}

int main() {
	ios_base::sync_with_stdio(false);
	cin.tie(NULL);
	int n, u, v, w;
	cin &gt;&gt; n;
	G.resize(n + 1);
	repp(i,1,n) {
		cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;
		G[u].push_back(edge(v, w));
		G[v].push_back(edge(u, w));
	}
	cin &gt;&gt; k;
	work(1);
	cout &lt;&lt; ans &lt;&lt; endl;
	return 0;
}
</code></pre>
<h2 id="cf161d">CF161D</h2>
<h3 id="事项-3">事项</h3>
<ol>
<li>two_pointer法直接解决 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>=</mo><mi>k</mi></mrow><annotation encoding="application/x-tex">=k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span> 过程中会有很大的分类讨论麻烦。为减轻代码难度可适当牺牲常数 : 实现<code>calc(k)</code>统计 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>⩽</mo><mi>k</mi></mrow><annotation encoding="application/x-tex">\leqslant k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7733399999999999em;vertical-align:-0.13667em;"></span><span class="mrel amsrm">⩽</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span> , 用<code>calc(k) - calc(k-1)</code>求 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>=</mo><mi>k</mi></mrow><annotation encoding="application/x-tex">=k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span> 。</li>
<li>可用map , 对每棵子树calc-add。然后启发式合并。(没实现过)</li>
</ol>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
#define endl '\n'
#define rep(i,a,b) for(int i=a;i&lt;=(b);++i)
#define per(i,a,b) for(int i=a;i&gt;=(b);--i)
#define repp(i,a,b) for(int i=a;i&lt;(b);++i)
#define perr(i,a,b) for(int i=a;i&gt;(b);--i)
#define pb push_back
#define rz resize
#define itra std::vector&lt;int&gt;::iterator;
#define VI vector&lt;int&gt;
#define VL vector&lt;long long&gt;
#define VD vector&lt;double&gt;

using namespace std;

typedef long long ll;
typedef pair&lt;int,int&gt; pii;

const int maxn = 56789;

typedef vector&lt; vector&lt;int&gt; &gt; graph;
graph G;
long long ans = 0;
int k;
int stk[maxn], top;
int siz[maxn], fa[maxn];
int dis[maxn], col[maxn];
bool del[maxn];
int num[maxn];


void dfs1(int pre, int cur) {
	siz[cur] = 1; fa[cur] = pre;
	stk[top++] = cur;
	for(int ver : G[cur])
		if(ver != pre &amp;&amp; !del[ver]) {
			dfs1(cur, ver);
			siz[cur] += siz[ver];
		}
}

int findroot(int xx) {
	stk[0] = xx; top = 1;
	siz[xx] = 1;
	for(int ver : G[xx]) 
		if(!del[ver]) {
			dfs1(xx, ver);
			siz[xx] += siz[ver];
		}
	for(int i = 0; i &lt; top; ++i) {
		int cur = stk[i];
		if(top - siz[cur] &gt; top / 2) continue;
		bool flg = true;
		for(int ver : G[cur])	
			if(!del[ver] &amp;&amp; ver != fa[cur] &amp;&amp; siz[ver] &gt; top / 2) {
				flg = false; break;
			}
		if(flg) return cur;
	}
}

void dfs2(int pre, int cur, int color) {
	dis[cur] = dis[pre] + 1;
	col[cur] = color;
	for(int ver : G[cur])
		if(!del[ver] &amp;&amp; ver != pre)
			dfs2(cur, ver, color);
}

long long calc(int k) {
	long long ans = 0;
	int l = 0, r = top - 1;
	for(int i = 1; i &lt; top; ++i) ++num[col[stk[i]]];
	for(; l &lt; r; --num[col[stk[++l]]]) {
		while(dis[stk[r]] + dis[stk[l]] &gt; k) {
			--num[col[stk[r]]]; --r;
		}
		if(r &gt; l)
			ans += r - l - num[col[stk[l]]];
	}
	for(int i = 0; i &lt; top; ++i) num[col[stk[i]]] = 0;
	return ans;
}

void work(int xx) {
	xx = findroot(xx);
	if(top == 1) return;
	col[xx] = dis[xx] = 0;
	for(int ver : G[xx])
		if(!del[ver])
			dfs2(xx, ver, ver);
	sort(stk, stk + top, [&amp;](int x, int y){ return dis[x] &lt; dis[y]; });
	ans += calc(k) - calc(k-1);
	del[xx] = true;
	for(int ver : G[xx])
		if(!del[ver])
			work(ver);
}

int main() {
	ios_base::sync_with_stdio(false);
	cin.tie(NULL);
	int n, u, v;
	cin &gt;&gt; n &gt;&gt; k;
	G.resize(n + 1);
	repp(i,1,n) {
		cin &gt;&gt; u &gt;&gt; v;
		G[u].push_back(v);
		G[v].push_back(u);
	}
	work(1);
	cout &lt;&lt; ans &lt;&lt; endl;
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[2020-07-19 训练日记]]></title>
        <id>https://froldh.github.io/post/2020-07-19-xun-lian-ri-ji/</id>
        <link href="https://froldh.github.io/post/2020-07-19-xun-lian-ri-ji/">
        </link>
        <updated>2020-07-19T08:41:04.000Z</updated>
        <summary type="html"><![CDATA[<h2 id="view">View</h2>
<ol>
<li><a href="https://codeforces.com/contest/1379/problem/B">CF1379B (#657Div2B)</a></li>
<li><a href="https://codeforces.com/contest/1379/problem/C">CF1379C (#657Div2C)</a></li>
</ol>
]]></summary>
        <content type="html"><![CDATA[<h2 id="view">View</h2>
<ol>
<li><a href="https://codeforces.com/contest/1379/problem/B">CF1379B (#657Div2B)</a></li>
<li><a href="https://codeforces.com/contest/1379/problem/C">CF1379C (#657Div2C)</a></li>
</ol>
<!-- more -->  
<h2 id="detail">detail</h2>
<h3 id="cf1379b-657div2b">CF1379B (#657Div2B)</h3>
<h4 id="思路">思路</h4>
<p>枚举a , 贪心求 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">∣</mi><mi>b</mi><mo>−</mo><mi>c</mi><mi mathvariant="normal">∣</mi></mrow><annotation encoding="application/x-tex">|b-c|</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord mathdefault">b</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">c</span><span class="mord">∣</span></span></span></span> 的两个最小值(分别在<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>b</mi><mo>−</mo><mi>c</mi><mo>⩾</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">b - c \geqslant 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">b</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.7733399999999999em;vertical-align:-0.13667em;"></span><span class="mord mathdefault">c</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel amsrm">⩾</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>b</mi><mo>−</mo><mi>c</mi><mo>⩽</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">b - c \leqslant 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">b</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.7733399999999999em;vertical-align:-0.13667em;"></span><span class="mord mathdefault">c</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel amsrm">⩽</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> )时。然后看能否构造符合的解。<br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="script">O</mi><mo>(</mo><mi>r</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O(r)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mclose">)</span></span></span></span></span></p>
<h4 id="code">code</h4>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
#define endl '\n'
#define rep(i,a,b) for(int i=a;i&lt;=(b);++i)
#define per(i,a,b) for(int i=a;i&gt;=(b);--i)
#define repp(i,a,b) for(int i=a;i&lt;(b);++i)
#define perr(i,a,b) for(int i=a;i&gt;(b);--i)
#define pb push_back
#define rz resize
#define itra std::vector&lt;int&gt;::iterator;
#define VI vector&lt;int&gt;
#define VL vector&lt;long long&gt;
#define VD vector&lt;double&gt;
 
using namespace std;
 
typedef long long ll;
typedef pair&lt;int,int&gt; pii;
 
inline void ponchline() { cout &lt;&lt; &quot;##################################&quot; &lt;&lt; endl; }
inline ll qp(ll a, ll b, ll p) { ll res = 1%p; for(;b;b&gt;&gt;=1) { if(b&amp;1)res=res*a%p; a=a*a%p; } return res; }
inline ll gcd(ll a, ll b) { while(b) { int t = b; b = a%b; a=t; } return a; }
mt19937 mrand(random_device{}()); int rnd(int x) { return mrand() % x;}
 
const int inf = 0x3f3f3f3f;
const ll linf = 0x3f3f3f3f3f3f3f3f;
 
//vector&lt; VI &gt; edge;
 
int main() {
	ios::sync_with_stdio(false);
	cin.tie(0);
	int tests;
	cin&gt;&gt;tests;
	while(tests--) {
		ll l, r, m;
		cin &gt;&gt; l &gt;&gt; r &gt;&gt; m;
		for(ll a = r; a &gt;= l; --a) {
			ll t = m % a;
			if(t &lt;= r - l &amp;&amp; m / a != 0) {
				cout &lt;&lt; a &lt;&lt; ' ' &lt;&lt; l + t &lt;&lt; ' ' &lt;&lt; l &lt;&lt; endl;
				break;
			}
			if((m / a + 1) * a - m &lt;= r - l) {
				cout &lt;&lt; a &lt;&lt; ' ' &lt;&lt; r - ((m / a + 1) * a - m) &lt;&lt; ' ' &lt;&lt; r &lt;&lt; endl;
				break;	
			}
 		}
	}
	return 0;
}
 
</code></pre>
<h3 id="cf1379c-657div2c">CF1379C (#657Div2C)</h3>
<h4 id="思路-2">思路</h4>
<p>b可以选择无限种 , 至多只能选一种的b。<br>
枚举选择的b , 贪心求选哪些a。<br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="script">O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O(n)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></span></p>
<h4 id="事项">事项</h4>
<p>注意二分的边界情况 , pls = 0可能是一个都不能选(建议下标从1开始并给0设置一个边界值以区分) , 要特判。</p>
<h4 id="code-2">code</h4>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
#define endl '\n'
#define rep(i,a,b) for(int i=a;i&lt;=(b);++i)
#define per(i,a,b) for(int i=a;i&gt;=(b);--i)
#define repp(i,a,b) for(int i=a;i&lt;(b);++i)
#define perr(i,a,b) for(int i=a;i&gt;(b);--i)
#define pb push_back
#define rz resize
#define itra std::vector&lt;int&gt;::iterator;
#define VI vector&lt;int&gt;
#define VL vector&lt;long long&gt;
#define VD vector&lt;double&gt;

using namespace std;

typedef long long ll;
typedef pair&lt;int,int&gt; pii;

inline void ponchline() { cout &lt;&lt; &quot;##################################&quot; &lt;&lt; endl; }
inline ll qp(ll a, ll b, ll p) { ll res = 1%p; for(;b;b&gt;&gt;=1) { if(b&amp;1)res=res*a%p; a=a*a%p; } return res; }
inline ll gcd(ll a, ll b) { while(b) { int t = b; b = a%b; a=t; } return a; }
mt19937 mrand(random_device{}()); int rnd(int x) { return mrand() % x;}

const int inf = 0x3f3f3f3f;
const ll linf = 0x3f3f3f3f3f3f3f3f;
const int maxn = 123456;

//vector&lt; VI &gt; edge;

struct pr {
	int x, y;
	pr() {}	
	pr(int x, int y) : x(x), y(y) {}
} prs[maxn];

ll sum[maxn];

int getpls(int l, int r, int key) {
	while(l &lt; r) {
		int mid = (l + r + 1) &gt;&gt; 1;
		if(prs[mid].x &gt;= key) l = mid;
		else r = mid - 1;
	}
	return l;
}

int main() {
	ios::sync_with_stdio(false);
	cin.tie(0);
	int tests;
	cin&gt;&gt;tests;
	while(tests--) {
		int n, m, nn;
		cin &gt;&gt; n &gt;&gt; m;
		nn = n;
		for(int i = 0; i &lt; m; ++i) cin &gt;&gt; prs[i].x &gt;&gt; prs[i].y;
		sort(prs, prs + m, [&amp;](pr x, pr y){return x.x &gt; y.x || x.x == y.x &amp;&amp; x.y &gt; y.y;});
		sum[0] = prs[0].x;
		for(int i = 1; i &lt; m; ++i) sum[i] = sum[i-1] + prs[i].x;
		ll ans = sum[min(m-1, n-1)], tt;
		for(int i = 0; i &lt; m; ++i) {
			tt = 0;
			int pls = getpls(0, m - 1, prs[i].y);
			if(prs[pls].x &lt; prs[i].y) pls = -1;
			if(pls + 1 &gt;= n) ans = max(ans, sum[n - 1]);
			else {
				if(~pls) {
					tt += sum[pls];
					n -= pls + 1;
				}
				if(i &gt; pls) --n, tt += prs[i].x;
				tt += 1ll * n * prs[i].y;
				ans = max(ans, tt);
			}
			n = nn;
		}
		cout &lt;&lt; ans &lt;&lt; endl;
	}
	return 0;
}


</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[2020-07-16 训练日记]]></title>
        <id>https://froldh.github.io/post/2020-07-16-xun-lian-ri-ji/</id>
        <link href="https://froldh.github.io/post/2020-07-16-xun-lian-ri-ji/">
        </link>
        <updated>2020-07-16T13:29:21.000Z</updated>
        <summary type="html"><![CDATA[<h2 id="view">view</h2>
<ol>
<li>学会了fft</li>
<li>过了<a href="https://www.luogu.com.cn/problem/P3803">fft板子</a></li>
</ol>
]]></summary>
        <content type="html"><![CDATA[<h2 id="view">view</h2>
<ol>
<li>学会了fft</li>
<li>过了<a href="https://www.luogu.com.cn/problem/P3803">fft板子</a></li>
</ol>
<!-- more -->  
<h2 id="detail">detail</h2>
<h3 id="fft板子">fft板子</h3>
<h4 id="talk">talk</h4>
<p>终于学会了fft , 在某位L姓带佬的指导下。<br>
话说能给我这种理解能力和水平巨差的人全程讲下来真的不容易qaq<br>
稍微记一点关键的东西备忘 , 实际上多数还是源于该带佬的blog</p>
<h4 id="note">note</h4>
<p>没写完 , 咕咕咕~</p>
<h4 id="code">code</h4>
<pre><code class="language-cpp">void dft(cp *a, int n) {
	if(n == 1) return;
	int hf = n &gt;&gt; 1;
	cp a0[hf], a1[hf];
	for(int i = 0; i &lt; hf; ++i)	{
		a0[i] = a[i&lt;&lt;1];
		a1[i] = a[i&lt;&lt;1|1];
	}
	dft(a0, hf);
	dft(a1, hf);
	for(int i = 0; i &lt; hf; ++i) {
		cp omg = cp(cos(2*PI*i/n), sin(2*PI*i/n));
		a[i] = a0[i] + omg * a1[i];
		a[i+hf] = a0[i] - omg * a1[i];	
	}
}

void idft(cp *a, int n) {
	reverse(a + 1, a + n);
	dft(a, n);
	for(int i = 0; i &lt; n; ++i) a[i] = a[i] / n;
}
</code></pre>
<h3 id="p3803-fft板子">P3803  fft板子</h3>
<h4 id="事项">事项 :</h4>
<ol>
<li>需要使用二进制翻转进行卡常 , 通过观察容易发现在fft递归到底层之后的下标值为原下标的二进制翻转(长度为序列长度) , 该过程可以使用 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="script">O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O(n)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></span> 递推求解 ，即 <code>t[i] = t[i&gt;&gt;1]&gt;&gt;1 + (i&amp;n?n&gt;&gt;1:0)</code></li>
<li>复数单位根应当采用递推的形式去做 , 即 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msubsup><mi>ω</mi><mi>n</mi><mi>i</mi></msubsup><mo>=</mo><msubsup><mi>ω</mi><mi>n</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msubsup><mo>∗</mo><msub><mi>ω</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">\omega_{n}^i = \omega_{n}^{i-1}*\omega_{n}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.071664em;vertical-align:-0.247em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.824664em;"><span style="top:-2.4530000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.071664em;vertical-align:-0.247em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.824664em;"><span style="top:-2.4530000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><br>
<strong>好的操作</strong><br>
<img src="https://froldh.github.io/post-images/1594908193797.png" alt="" loading="lazy"><br>
<strong>不优的操作</strong><br>
<img src="https://froldh.github.io/post-images/1594908205241.png" alt="" loading="lazy"></li>
</ol>
<h4 id="code-2">code</h4>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;

using namespace std;

const double PI = acos(-1);
const int maxn = 2345678;

struct cp {
	double x, y;
	cp() { x = y = 0; }
	cp(double X, double Y) : x(X), y(Y) {}
	cp operator + (const cp&amp; o) const {
		return cp(x + o.x, y + o.y);
	}
	cp operator - (const cp&amp; o) const {
		return cp(x - o.x, y - o.y);
	}
	cp operator * (const cp&amp; o) const {
		return cp(x*o.x-y*o.y, x*o.y+y*o.x);	
	}
	void operator *= (const cp&amp; o) {
		double tx = x * o.x - y * o.y;
		y = x * o.y + y * o.x;
		x = tx;
	}
	void operator /= (const int&amp; n) {
		x /= n; y /= n;
	}
}a[maxn], b[maxn];

inline void flip(int &amp;x) {
	int t = 1;
	while(t &lt; x) t &lt;&lt;= 1;
	x = t;
}

int target[maxn];

void dft(cp a[], int n) {
	for(int i = 0; i &lt; n; ++i) if(i &lt;= target[i]) swap(a[i], a[target[i]]);
	for(int m = 2; m &lt;= n; m &lt;&lt;= 1) {
		int hf = m &gt;&gt; 1;
		for(int i = 0; i &lt; n; i += m) {
			cp w0 = cp(cos(2*PI/m), sin(2*PI/m));
			cp omg = cp(1, 0);
			for(int k = 0; k &lt; hf; ++k, omg *= w0) {
				cp t = omg * a[i+k+hf];
				a[i+k+hf] = a[i+k] - t;
				a[i+k] = a[i+k] + t;
			}
		}
	}
}

void idft(cp a[], int n) {
	reverse(a + 1, a + n);
	dft(a, n);
	for(int i = 0; i &lt; n; ++i) a[i] /= n;
}

int main() {
	ios_base::sync_with_stdio(false);
	cin.tie(NULL);
	int n, m;
	cin &gt;&gt; n &gt;&gt; m;
	for(int i = 0; i &lt;= n; ++i) cin &gt;&gt; a[i].x;
	for(int i = 0; i &lt;= m; ++i) cin &gt;&gt; b[i].x;
	int len = n + m + 1;
	flip(len);
	for(int i = 0; i &lt; len; ++i)
		target[i] = target[i&gt;&gt;1]&gt;&gt;1 | (i&amp;1?len&gt;&gt;1:0);
	dft(a, len);
	dft(b, len);
	for(int i = 0; i &lt; len; ++i) a[i] *= b[i];
	idft(a, len);
	for(int i = 0; i &lt;= n + m; ++i) cout &lt;&lt; (int)(a[i].x + 0.5) &lt;&lt; ' ';
	cout &lt;&lt; endl;
	return 0;
}
</code></pre>
<h2 id="thought">thought</h2>
<p>今天被一些事情缠住了 , 没怎么做题qaq<br>
明天下午好像还要去兵役体检啊QaQ , 明明我近视500°的说 , 一下午又要没了(心疼)<br>
明天上午有ACM集训的白嫖课 , 开心~</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[2020-07-15 训练日记]]></title>
        <id>https://froldh.github.io/post/2020-07-15-xun-lian-ri-ji/</id>
        <link href="https://froldh.github.io/post/2020-07-15-xun-lian-ri-ji/">
        </link>
        <updated>2020-07-15T07:26:39.000Z</updated>
        <summary type="html"><![CDATA[<h2 id="view">view</h2>
<ol>
<li>过了<a href="https://www.luogu.com.cn/problem/P5180">洛谷支配树的板子</a></li>
<li>过了<a href="http://acm.hdu.edu.cn/showproblem.php?pid=4694">HDU4694 ImportantSister(支配树裸题)</a></li>
<li>过了wmd支配树课件的习题<a href="https://www.codechef.com/problems/GRAPHCNT">CodeChef - GRAPHCNT</a></li>
<li>开始写支配树的笔记和总结(应该会咕很久)</li>
</ol>
]]></summary>
        <content type="html"><![CDATA[<h2 id="view">view</h2>
<ol>
<li>过了<a href="https://www.luogu.com.cn/problem/P5180">洛谷支配树的板子</a></li>
<li>过了<a href="http://acm.hdu.edu.cn/showproblem.php?pid=4694">HDU4694 ImportantSister(支配树裸题)</a></li>
<li>过了wmd支配树课件的习题<a href="https://www.codechef.com/problems/GRAPHCNT">CodeChef - GRAPHCNT</a></li>
<li>开始写支配树的笔记和总结(应该会咕很久)</li>
</ol>
<!-- more -->
<h2 id="detail">detail</h2>
<h3 id="luogup5180">luoguP5180</h3>
<h4 id="事项">事项</h4>
<ol>
<li>不要把dfn[x]的比较写成x的比较 , 不要把sdom[x]的比较写成x的比较。</li>
</ol>
<h4 id="code">code</h4>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
#define endl '\n'
#define rep(i,a,b) for(int i=a;i&lt;=(b);++i)
#define per(i,a,b) for(int i=a;i&gt;=(b);--i)
#define repp(i,a,b) for(int i=a;i&lt;(b);++i)
#define perr(i,a,b) for(int i=a;i&gt;(b);--i)
#define pb push_back
#define rz resize
#define VI vector&lt;int&gt;

using namespace std;

vector&lt; VI &gt; G, _G, GDOM;
VI dfn, idfn, fa;
int dfs_clock = 1;

void dfs(int pre, int cur) {
	idfn[dfs_clock] = cur;
	dfn[cur] = dfs_clock++;
	fa[cur] = pre;
	for(int ver : G[cur])
		if(!dfn[ver])
			dfs(cur, ver);
}

inline int minpt(int u, int v) {
	return dfn[u] &lt; dfn[v] ? u : v;	
}

VI par, dat, sdom, idom;
vector&lt; VI &gt; buc;
int eval(int cur) {
	if(par[cur] == cur) return cur;
	int anc = eval(par[cur]);
	dat[cur] = dfn[sdom[dat[cur]]] &lt; dfn[sdom[dat[par[cur]]]] ? dat[cur] : dat[par[cur]];
	return par[cur] = anc;
}


void lengauer_tarjan(int n) {
	for(int i = n; i; --i) sdom[i] = i, par[i] = i, dat[i] = i;
	for(int i = n; i &gt; 1; --i) {
		int cur = idfn[i];
		for(int ver : _G[cur]) {
			if(!dfn[ver]) continue;
			eval(ver); 
			sdom[cur] = minpt(sdom[cur], sdom[dat[ver]]);
		}
		par[cur] = fa[cur]; dat[cur] = sdom[cur];
		buc[sdom[cur]].pb(cur);
		for(int ver : buc[fa[cur]]) {
			eval(ver);
			if(sdom[dat[ver]] == fa[cur]) idom[ver] = sdom[ver];
			else idom[ver] = dat[ver];
		}
		buc[fa[cur]].clear();
	}
	rep(i,1,n) {
		int cur = idfn[i]; 
		if(idom[cur] != sdom[cur]) idom[cur] = idom[idom[cur]];
	} 
}

VI ans;

void work(int cur) {
	ans[cur] = 1;
	for(int ver : GDOM[cur]) {
		work(ver);
		ans[cur] += ans[ver];
	}
}

int main() {
	ios::sync_with_stdio(false);
	cin.tie(nullptr);
	int n, m, u, v;
	cin &gt;&gt; n &gt;&gt; m;
	G.rz(n + 1); _G.rz(n + 1); GDOM.rz(n + 1); dfn.rz(n + 1); idfn.rz(n + 1); fa.rz(n + 1); par.rz(n + 1); dat.rz(n + 1); sdom.rz(n + 1); idom.rz(n + 1); buc.rz(n + 1); ans.rz(n + 1);
	while(m--) {
		cin &gt;&gt; u &gt;&gt; v;
		G[u].pb(v);
		_G[v].pb(u);
	}
	dfs(0, 1);
	lengauer_tarjan(n);
	rep(i,1,n) GDOM[idom[i]].pb(i);
	work(1);
	rep(i,1,n) cout &lt;&lt; ans[i] &lt;&lt; ' ';
	cout &lt;&lt; endl;
	return 0;
}
</code></pre>
<h3 id="hdu4694-important-sister">HDU4694 Important Sister</h3>
<h4 id="事项-2">事项</h4>
<ol>
<li>注意并查集中保存的是sdom[x]最小的点的编号而不是sdom的最小值。</li>
<li>有些点在流图中不可达 , 所以支配树中点的个数应为dfs后dfs_clock - 1。</li>
<li>初始化sdom[x] = par[x] = dat[x] = x;</li>
<li>不要把并查集的par[]和dfs树中的fa[]搞混淆</li>
<li>不要忘记清空buc[]</li>
<li>一个点求完在并查集中挂fa在buc中挂sdom , 但是弹出是弹出fa</li>
<li>r无支配点 , 记idom[r] = 0</li>
<li>最后一步调整的过程为dfn升序</li>
</ol>
<h4 id="code-2">code</h4>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;

using namespace std;


typedef vector&lt; vector&lt;int&gt; &gt; Graph;

const int maxn = 56789;

Graph G, _G, DOM;
vector&lt; vector&lt;int&gt; &gt; buc;
int dfn[maxn], idfn[maxn], fa[maxn], dfs_clock = 1;
int par[maxn], dat[maxn];
int sdom[maxn], idom[maxn];

void dfs(int pre, int cur) {
	idfn[dfs_clock] = cur; dfn[cur] = dfs_clock++;
	fa[cur] = pre;
	for(int ver : G[cur]) if(!dfn[ver]) dfs(cur, ver);
}

int find(int x) {
	if(par[x] == x) return x;
	int p = find(par[x]);
	if(dfn[sdom[dat[par[x]]]] &lt; dfn[sdom[dat[x]]]) dat[x] = dat[par[x]];
	return par[x] = p;
}

inline int eval(int x) { find(x); return dat[x]; }

void lengauer_tarjan(int n, int r) {
	memset(dfn, 0, sizeof(dfn));
	memset(idfn, 0, sizeof(dfn));
	memset(fa, 0, sizeof(fa));
	memset(idom, 0, sizeof(idom));
	dfs_clock = 1;
	dfs(0, r);
	--dfs_clock;
	for(int i = 1; i &lt;= n; ++i) par[i] = dat[i] = sdom[i] = i;
	for(int i = dfs_clock; i &gt; 1; --i) {
		int cur = idfn[i];
		for(int ver : _G[cur]) {
			if(!dfn[ver]) continue;
			int ev = eval(ver);
			if(dfn[sdom[cur]] &gt; dfn[sdom[ev]]) sdom[cur] = sdom[ev];
		}
		par[cur] = fa[cur]; buc[sdom[cur]].push_back(cur);
		for(int ver : buc[fa[cur]]) {
			if(sdom[eval(ver)] == fa[cur]) idom[ver] = fa[cur];
			else idom[ver] = eval(ver);
		}
		buc[fa[cur]].clear();
	}
	for(int i = 2; i &lt;= dfs_clock; i++) {
			int cur = idfn[i];
			if(idom[cur] != sdom[cur]) idom[cur] = idom[idom[cur]];
	}
	idom[r] = 0;
}

long long ans[maxn];
void work(int pre, int cur) {
	ans[cur] = cur + ans[pre];
	for(int ver : DOM[cur])
		work(cur, ver);
} 

int main() {
	ios::sync_with_stdio(false);
	cin.tie(nullptr);
	cout.tie(nullptr);
	int n, m, r;
	while(cin &gt;&gt; n &gt;&gt; m) {
		r = n;
		G.clear(); G.resize(n + 1);
		_G.clear(); _G.resize(n + 1);
		DOM.clear(); DOM.resize(n + 1);
		buc.clear(); buc.resize(n + 1);
		int u, v;
		while(m--) {
			cin &gt;&gt; u &gt;&gt; v;
			G[u].push_back(v);
			_G[v].push_back(u);
		}
		lengauer_tarjan(n, r);
		for(int i = 1; i &lt;= n; ++i) {
			DOM[idom[i]].push_back(i);
		}
		memset(ans, 0, sizeof(ans));
		work(0, r);
		for(int i = 1; i &lt; n; ++i) cout &lt;&lt; ans[i] &lt;&lt; ' ';
		cout &lt;&lt; ans[n] &lt;&lt; endl;
	}
	return 0;
}
</code></pre>
<h3 id="codechef-graphcnt">CodeChef - GRAPHCNT</h3>
<h4 id="分析">分析</h4>
<p>原问题可转化为求支配树上lca = r的有序点对数量和<br>
另一种count法挂了，没搞清楚为什么qaq</p>
<h4 id="事项-3">事项</h4>
<ol>
<li>大于号方向注意不要搞反</li>
</ol>
<h4 id="code-3">code</h4>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt; 
#define pb push_back
#define rz resize

using namespace std;

typedef vector&lt;int&gt; VI;
typedef vector&lt;VI&gt; Graph;
typedef long long ll;

const int maxn = 123456;

Graph G, _G, DOM;
VI buc[maxn];
int dfn[maxn], idfn[maxn], fa[maxn], dfs_clock;
int par[maxn], dat[maxn];
int sdom[maxn], idom[maxn];

void dfs(int pre, int cur) {
	idfn[dfs_clock] = cur; dfn[cur] = dfs_clock++;
	fa[cur] = pre;
	for(int ver : G[cur]) if(!dfn[ver]) dfs(cur, ver);
}

int find(int x) {
	if(par[x] == x) return x;
	int p = find(par[x]);
	if(dfn[sdom[dat[x]]] &gt; dfn[sdom[dat[par[x]]]]) dat[x] = dat[par[x]];
	return par[x] = p;
}

int eval(int x) { find(x); return dat[x]; }

void lengauer_tarjan(int n, int r) {
	dfs_clock = 1;
	dfs(0, r);
	--dfs_clock;
	for(int i = 1; i &lt;= n; ++i) par[i] = dat[i] = sdom[i] = i;
	for(int i = n; i &gt; 1; --i) {
		int cur = idfn[i];
		for(int ver : _G[cur]) {
			if(!dfn[ver]) continue;
			int ev = eval(ver);
			if(dfn[sdom[cur]] &gt; dfn[sdom[ev]]) sdom[cur] = sdom[ev];
		}
		buc[sdom[cur]].pb(cur); par[cur] = fa[cur];
		for(int ver : buc[fa[cur]]) {
			int ev = eval(ver);
			if(sdom[ev] == fa[cur]) idom[ver] = fa[cur];
			else idom[ver] = ev;
		}
		buc[fa[cur]].clear();
	}
	for(int i = 2; i &lt;= dfs_clock; ++i) {
		int cur = idfn[i];
		if(idom[cur] != sdom[cur]) idom[cur] = idom[idom[cur]];
		DOM[idom[cur]].pb(cur); 
	}
	idom[r] = 0;
}

int siz[maxn];
ll ans = 0;
void work(int cur) {
	siz[cur] = 1;
	for(int ver : DOM[cur]) {
		work(ver);
		if(cur == 1) ans += 1ll * siz[cur] * siz[ver];
		siz[cur] += siz[ver]; 
	}
}

int main() {
	ios_base::sync_with_stdio(false);
	cin.tie(NULL);
	int n, m, u, v;
	cin &gt;&gt; n &gt;&gt; m;
	G.rz(n + 1); _G.rz(n + 1); DOM.rz(n + 1);
	while(m--) {
		cin &gt;&gt; u &gt;&gt; v;
		G[u].pb(v);
		_G[v].pb(u);
	}
	lengauer_tarjan(n, 1);
	work(1);
	cout &lt;&lt; ans &lt;&lt; endl;
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[HDU三位一体招生游记]]></title>
        <id>https://froldh.github.io/post/hdu-san-wei-yi-ti-zhao-sheng-you-ji/</id>
        <link href="https://froldh.github.io/post/hdu-san-wei-yi-ti-zhao-sheng-you-ji/">
        </link>
        <updated>2020-07-13T15:00:22.000Z</updated>
        <content type="html"><![CDATA[<h2 id="day-1">DAY-1</h2>
<p>看着带佬们都能zju和复旦交大的三一还是蛮酸的。<br>
1月小高考分数没救的我只能报了hdu qaq<br>
day1考笔试，由于w报的信息类特长生所以免笔试，改考6道OI题。<br>
day2考面试。</p>
<h2 id="day0">DAY0</h2>
<p>9:40上大巴，然后掏出手机问wz带佬什么时候去，wz说明天上午5点直接出发8点可到考场。这也太刚了。<br>
有看没看看了一些支配树的内容，不过没有很看懂，车上也有点晕车就把手机关掉了。<br>
中午饭在服务区解决，三个素菜50多块wdnmd，味道还行。<br>
下午三点到旅馆，房间还是蛮不错的。<br>
<img src="https://froldh.github.io/post-images/1594679716523.jpg" alt="" loading="lazy"><br>
晚饭后在大街上乱晃了一会儿，回到宾馆打隔膜，继续康支配树。<br>
夜景<br>
<img src="https://froldh.github.io/post-images/1594680207660.jpg" alt="" loading="lazy"></p>
<h2 id="day1">DAY1</h2>
<p>早上5:30醒了，打了半个小时隔膜，然后简单地看了一下常考算法的板子。<br>
7:00去宾馆自助餐厅，炒面好评，咖啡好评。好像是因为三一的缘故宾馆又离hdu特别进所以次早饭的人特别多，被挤成鸽子干。<br>
<img src="https://froldh.github.io/post-images/1594679888158.jpg" alt="" loading="lazy"><br>
7:50到了HDU，找楼走过了头，最后还是进去了。在报到点签到等着。右前方一个Cu带佬和一个Ag带佬谈笑风生，蒟蒻瑟瑟发抖，拿出CCF的恰烂钱tg书看了一会儿。<br>
<img src="https://froldh.github.io/post-images/1594679997158.jpg" alt="" loading="lazy"><br>
8:30进了考场，机子联网但只能上hdoj，其他网站上不去。然后发了三一测试的账号密码。然后突发奇想地登了自己以前的hdoj账号发现能上，还能看到以前做的题。后来主监考来说以前有hdoj的号的不许登进去，吓得我赶紧退掉了。顺带说一下赛制是伪ACM赛制，得分按照AC数且最终折分数不按罚时(就是特长测试的30pts按照每题6pts给分)，但是网页里面显示的ranklist还是把罚时计入在内的。<br>
8:40开始疯狂堆头，各种define和小函数搞上去。<br>
9:00开题(因为hdu特长生3=就能报进，所以没什么难度，大概最难的题pj/tg-)，时长2h。<br>
T1是个dp，再看一眼只需要用两个变量存一下扫过去就好了，4min写掉排在rank2。T2是个前缀和题, 快速打完交上，9min，wa掉了，疯狂改了一通交了几遍发现还是WA。看了一下status发现T2多数人狂WA。跳过看T3。此时过去了19min。T3是一个字符串水题，在第22min切掉发现排在rank8。T4要求建立一个BST然后输出层次遍历。sb鸽子举手问了是否会有相同点(题目没说清楚)，以及层次遍历事什么(我当时问的好像是bfs吗然后主监考白了我一眼说我不能这么跟你说，我只能说是一层一层输出)。然后rank1大佬31minAK起身离场了%%%。在38min打完了T4开T5，是个二分答案题，打完发现过不了样例调了一下，52min提交AC。然后去搞T2最后发现指定区间没有说左端点一定在前，然后哭着改掉58minAC。这时候已经有6个带佬起身走了。整了一下东西，邻桌的带佬也切完了。然后两个人开始找楼梯……<br>
以为不能出去两个人就在hdu晃了大概30min，聊东聊西，从OI聊到今年高考题。隔壁带佬高二退役noip480%%%。然后带佬对我校没有教练没有校队表示很震惊。我则是震惊于带城里人学OI竟然要花销20w。(草鸽子就高三暑假去过一次qbxt花了8k最后因为拿了csp2=学校还给报销了80%)。还说到什么机构1w辅导费但是请到考前请命题人讲课泄题，今年高考语文数学怎么怎么样，他们学校校长专门给女儿弄了个“公主班”……<br>
由于提前离场没等到考笔试的wz带佬，被老爹拉去次饭了。中午是个素食自助餐，不过东西不是很多，姑且喝了很多燕麦汁。<br>
12:30回到宾馆翻手机，看了一眼hdoj发现排在rank12(草为什么我明明第是七个打完的)，后来一看表发现虽然其他题目一遍过但是T2(-7)罚时炸成狗，草我原来交了7遍的撒。然后关掉hdoj开始打隔膜康瑟图逛车群顺带调戏ljf带佬。<br>
15:00继续康支配树，不到一个小时被老爹敲门拉去次饭了。<br>
晚饭在顺旺基快餐店里点了个卷心菜和番茄炒蛋，卷心菜居然是辣的(鸽子考前忌辣)。但是味道好评以至于多干了一碗饭(真·下饭)。<br>
<img src="https://froldh.github.io/post-images/1594680071735.jpg" alt="" loading="lazy"><br>
晚上打隔膜到20:30左右然后看了会儿支配树终于学会了。<br>
20:30 wz带佬跟我说他进面试了，然后和我一样都是下午场(面试分为上午场和下午场，主要是人多qaq)。<br>
22:30 捷克带佬打电话来哭他笔试没过(他当初大概以为信息类特长生考试很难然后他半年没动键盘所以没报特长生考笔试去了)。然后捷克在惊呼声中挂掉了电话(好像有一场CF开始3min了)。</p>
<h2 id="day2">DAY2</h2>
<p>4:50起床然后打了会儿隔膜，看了看zbyls友情提供的历届带佬面试心得，感觉好慌啊qaq<br>
然后6:30下楼到宾馆自助餐厅，一个人都没有。开始浏览发现除了白煮玉米和白煮鸡蛋什么素的都没有，心疼自己。只好坐在角落里啃玉米磕鸡蛋qaq。后来发现有燕麦片和热牛奶，就当场手冲了四碗喝掉。燕麦粥赛高！！！坐到7:20发现人还是很少，毕竟笔试刷掉的6/7的人都走了。<br>
<img src="https://froldh.github.io/post-images/1594680138062.jpg" alt="" loading="lazy"><br>
老爹说我初中一个关系不错的蛮强朋友也没过笔试，听到还是蛮难受的。<br>
回房继续看面试心得。<br>
中饭次沙县，勉强管饱。<br>
11:40到hdu，抽签是第四批，遇到了wz带佬，是第二批。坐在那里候场好长时间，wz带佬学了跳表然后教了我一波，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="script">O</mi><mo>(</mo><mi>n</mi><mi>log</mi><mo>⁡</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O(n \log n)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></span>代替平衡树的好东西啊。<br>
然后wz带佬去面试了，我继续等啊等啊等啊等了差不多1个钟头(后来看时间表应该是在2:30)终于本批次被叫到了，被带去另一个房间签个保证书然后通知继续等45min进考场。wtf！！！</p>
<h3 id="正式面试">正式面试</h3>
<p>被带进一个教室给15min读一段材料，不能动笔记录。<br>
下午场的材料内容是有关于汽车企业在数字化过程中和信息巨头之间的冲突的，大意是21世纪汽车正在和各产业交叉，尤其是信息产业，数字巨头希望将汽车行业作为自己产业生态链的一部分，而汽车产业希望自己掌握自己的一套数字化技术。<br>
我大概花了4min扫了一遍文章，心里划了下层次(感谢zbyls的缩文大法)。然后7min时间提取记忆了关键字，剩下3min左右整理了一下思路(大概就是从汽车巨头角度三层数字巨头角度两层)，并想了一下可能会被问的问题(猜中1/2)。<br>
然后在考场外面等上一批人结束，感觉我那个考场前面那个人好强，讲话丝毫不卡而且还带各种修辞。<br>
进到面试房间。<br>
一个房间有8个教授，进去之后教授先是提问材料相关的内容，再让要求做自我介绍，再是问一些时事相关的以及一些杂七杂八的问题，最后提一些个人相关的内容(这个好像是根据报名时写的个人自荐问的) 。<br>
刚开始，提问的主考官很和善，一个坐在角落的教授全程用一种玩味的眼神打量，剩下的人要么眼神无光要么低着头。<br>
先是两个和材料有关的问题。 印象非常深的就是我说到一半，一句他们要投入科研，需要一定量的资金，产品的开发也需要一定的周期……<br>
“科研”两个字刚说完那两个低着头的教授突然抬头，眼神放光(我当时差点吓了一跳)。<br>
所以讲话在关键点上很重要，不然教授根本不会关注你讲了什么，换言之你讲的可能都是无效内容。<br>
后面还问到和时事相关的题目，有一个题目是关于网课的，网课期间zbyls让我们写过作文，我那篇给打了50pts(50 / 60)，就花了6、7秒回想了一下主要的分论点，然后说了一遍。<br>
然后问了一些其他杂项的问题，一个印象比较深的问题就是你高中有没有住校，大学是肯定要住校的，你能不能适应。  我说我高一的时候住校。然后又问我为什么搬出去了，我说是因为竞赛需要用机子，学校肯定不让带进去的(真实原因只有鬼知道了)。<br>
最后和个人相关的内容，我写了很多算法竞赛有关的个人陈述，而且我的报名类型也是信息类特长生，所以问了我高中学过哪些算法数据结构，还问了我会不会实现什么什么(一些初级数据结构——栈，队列，堆(这里应该特指二叉堆)——和一些简单算法)。感觉主考官对我印象还蛮不错，跟我说我给你规划一下啊，如果你进了hdu可以申请一下免修算法和数据结构，做个免修考试过了就好了，多余的时间可以学一些高级的东西(听到这里我感觉自己稳了)。我跟他说我最近买了《编译原理》和《现代操作系统》打算暑假先自学一波，然后那个人点了点头。(hdu蛮给面子啊，8个考官我至少能确定有四个是信息相关的教授)<br>
这中间一个一直不发言的女教授突然问了个很刁难人的问题，还指出了我的话中可能存在的问题，有一种就是在弄你的感觉。感觉这个考官安排在那里就是挑刺和刁难，目的大概是为了考验考生的应变能力的。<br>
然后时间差不多到了，铃响了就结束了。<br>
总结就是说话一定要对到point上，然后不必要太紧张，尽可能展现自己真实的一面就好了。<br>
出考场返程，刚上滴滴车外面就下起了暴雨，运气蛮好qaq。在车站永和带王次了罗汉素食套餐，有点小贵但是味道蛮不错的。</p>
<h2 id="updateday9">(UPDATE)DAY9</h2>
<p>出分了 : 上机30/30pts + 面试 60.1/70pts = 90.1/100pts</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[题解(部分) Educational Codeforces Round 85 [Rated for Div. 2]]]></title>
        <id>https://froldh.github.io/post/ti-jie-bu-fen-educational-codeforces-round-85-rated-for-div-2/</id>
        <link href="https://froldh.github.io/post/ti-jie-bu-fen-educational-codeforces-round-85-rated-for-div-2/">
        </link>
        <updated>2020-04-11T02:30:25.000Z</updated>
        <content type="html"><![CDATA[<!-- more -->  
<h2 id="a">A</h2>
<p>判定状态是否合法 ,  首先初始状态中 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>p</mi><mn>0</mn></msub><mo>⩾</mo><msub><mi>c</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">p_0 \geqslant c_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83111em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel amsrm">⩾</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> ，然后在增量中 , <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span></span></span></span> 的增量大于 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi></mrow><annotation encoding="application/x-tex">c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">c</span></span></span></span> 的增量 , 即 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>p</mi><mi>i</mi></msub><mo>−</mo><msub><mi>p</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>⩾</mo><msub><mi>c</mi><mi>i</mi></msub><mo>−</mo><msub><mi>c</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msub><mo separator="true">,</mo><mi>i</mi><mo>∈</mo><mo>[</mo><mn>1</mn><mo separator="true">,</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo>]</mo></mrow><annotation encoding="application/x-tex">p_i - p_{i-1} \geqslant c_i - c_{i-1} , i \in [1, n-1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7777700000000001em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8450009999999999em;vertical-align:-0.208331em;"></span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel amsrm">⩾</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.73333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8678509999999999em;vertical-align:-0.208331em;"></span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span> 。</p>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
#define endl '\n'
#define rep(i,a,b) for(int i=a;i&lt;=(b);++i)
#define per(i,a,b) for(int i=a;i&gt;=(b);--i)
#define repp(i,a,b) for(int i=a;i&lt;(b);++i)
#define perr(i,a,b) for(int i=a;i&gt;(b);--i)
#define pb push_back
#define rz resize
#define VI vector&lt;int&gt;
#define VL vector&lt;long long&gt;
#define VD vector&lt;double&gt;

using namespace std;

typedef long long ll;

const int inf = 0x3f3f3f3f;
const ll linf = 0x3f3f3f3f3f3f3f3f;


int main() {
	ios::sync_with_stdio(false);
	cin.tie(0);
	int tests;
	cin&gt;&gt;tests;
	while(tests--) {
		int n, p, c, pi, ci;
		bool flg = true;
		cin&gt;&gt;n;
		--n;
		cin &gt;&gt; p &gt;&gt; c;
		if(p &lt; c) flg = false;
		while(n--) {
			cin &gt;&gt; pi &gt;&gt; ci;
			if(pi &lt; p || ci &lt; c || pi - p &lt; ci - c || pi &lt; ci) flg = false;
			p = pi; c = ci;
		}
		if(flg) cout &lt;&lt; &quot;YES&quot; &lt;&lt; endl;
		else cout &lt;&lt; &quot;NO&quot; &lt;&lt; endl;
	}
	return 0;
}

</code></pre>
<h2 id="b">B</h2>
<p>因为要平均分配 , 所以选择加入原先拥有钱数尽可能多的人一定是最优的。</p>
<p>因此对钱数排序 , 然后从左往右扫过去 , 看看平均值是否还大于等于 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> , 最后一次满足平均值大于等于 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> 的人数即为最大总人数。</p>
<p>复杂度 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="script">O</mi><mo>(</mo><mi>n</mi><mi>log</mi><mo>⁡</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O(n \log n)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></span></p>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
#define rep(i,a,b) for(int i=a;i&lt;=(b);++i)
#define per(i,a,b) for(int i=a;i&gt;=(b);--i)
#define repp(i,a,b) for(int i=a;i&lt;(b);++i)
#define perr(i,a,b) for(int i=a;i&gt;(b);--i)
#define pb push_back
#define rz resize
#define VI vector&lt;int&gt;
#define VL vector&lt;long long&gt;
#define VD vector&lt;double&gt;

using namespace std;

typedef long long ll;

const int inf = 0x3f3f3f3f, maxn = 12345;
const ll linf = 0x3f3f3f3f3f3f3f3f;

VI a;

int main() {
	ios::sync_with_stdio(false);
	cin.tie(0);
	int tests;
	cin&gt;&gt;tests;
	while(tests--) {
		int n, x;
		cin &gt;&gt; n &gt;&gt; x;
		a.assign(n+2, 0);
		rep(i,1,n) cin &gt;&gt; a[i];
		sort(&amp;a[1], &amp;a[n + 1], [&amp;](int ai, int bi){ return ai &gt; bi; });
		unsigned long long sum = 0;
		rep(i,1,n) {
			sum += a[i];
			if(sum / i &lt; x) {
				cout &lt;&lt; i - 1 &lt;&lt; endl;
				break;
			}
			if(i == n) cout &lt;&lt; n &lt;&lt; endl;
		}
	}
	return 0;
}
</code></pre>
<h2 id="c">C</h2>
<p>关键在于考虑尽量利用 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>b</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">b_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 。</p>
<p>一个怪 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 如果对后面一个产生爆炸伤害 , 就节省 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>c</mi><mi>i</mi></msub><mo>=</mo><mi>min</mi><mo>⁡</mo><mo>{</mo><msub><mi>b</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi>a</mi><mrow><mo>(</mo><mi>i</mi><mo>+</mo><mn>1</mn><mo>)</mo><mi mathvariant="normal">%</mi><mi>n</mi></mrow></msub><mo>}</mo></mrow><annotation encoding="application/x-tex">c_i = \min \{b_i , a_{(i+1)\%n}\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.1052em;vertical-align:-0.3551999999999999em;"></span><span class="mop">min</span><span class="mopen">{</span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.34480000000000005em;"><span style="top:-2.5198em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathdefault mtight">i</span><span class="mbin mtight">+</span><span class="mord mtight">1</span><span class="mclose mtight">)</span><span class="mord mtight">%</span><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3551999999999999em;"><span></span></span></span></span></span></span><span class="mclose">}</span></span></span></span> 。</p>
<p>如果是在一条链上 , 显然从头部打到尾部 , 就能充分利用 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>c</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">c_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 。</p>
<p>在一个环上 , 我们首先打掉一个怪 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> ， 那么怪 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi><mo>−</mo><mn>1</mn><mspace></mspace><mspace width="0.6666666666666666em"/><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mtext> </mtext><mtext> </mtext><mi>n</mi></mrow><annotation encoding="application/x-tex">i-1 \mod n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.74285em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mspace allowbreak"></span><span class="mspace" style="margin-right:0.6666666666666666em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">m</span><span class="mord mathrm">o</span><span class="mord mathrm">d</span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span></span></span></span> 对答案的贡献 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>c</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn><mspace></mspace><mspace width="0.6666666666666666em"/><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mtext> </mtext><mtext> </mtext><mi>n</mi></mrow></msub></mrow><annotation encoding="application/x-tex">c_{i-1 \mod n}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.638891em;vertical-align:-0.208331em;"></span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span><span class="mspace allowbreak mtight"></span><span class="mspace mtight" style="margin-right:0.7806666666666667em;"></span><span class="mord mtight"><span class="mord mtight"><span class="mord mathrm mtight">m</span><span class="mord mathrm mtight">o</span><span class="mord mathrm mtight">d</span></span></span><span class="mspace mtight" style="margin-right:0.19516666666666668em;"></span><span class="mspace mtight" style="margin-right:0.19516666666666668em;"></span><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span></span></span></span> 就不能计在内了 , 因此考虑找出最小的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>c</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">c_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>  , 舍去其爆炸伤害的贡献。</p>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
#define endl '\n'
#define rep(i,a,b) for(int i=a;i&lt;=(b);++i)
#define per(i,a,b) for(int i=a;i&gt;=(b);--i)
#define repp(i,a,b) for(int i=a;i&lt;(b);++i)
#define perr(i,a,b) for(int i=a;i&gt;(b);--i)
#define pb push_back
#define rz resize
#define VI vector&lt;int&gt;
#define VL vector&lt;long long&gt;
#define VD vector&lt;double&gt;

using namespace std;

typedef long long ll;


const int inf = 0x3f3f3f3f;
const ll linf = 0x3f3f3f3f3f3f3f3f;

VL a, b;

int main() {
	ios::sync_with_stdio(false);
	cin.tie(0);
	int tests;
	cin&gt;&gt;tests;
	while(tests--) {
		int n;
		ll ans = 0, reg = linf;
		cin &gt;&gt; n;
		a.resize(n + 2);
		b.resize(n + 2);
		rep(i,1,n) cin &gt;&gt; a[i] &gt;&gt; b[i], ans += a[i];
		rep(i,1,n) {
			ans -= min(b[i], a[i%n+1]);
			reg = min(reg, min(b[i], a[i%n+1]));
		}
		ans += reg;
		cout &lt;&lt; ans &lt;&lt; endl;
	}

	return 0;
}
</code></pre>
<h2 id="d">D</h2>
<p>考虑规律 , 通过简单的贪心或者打表可以得到</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>:</mo><mn>1</mn><mtext> </mtext><mn>2</mn><mtext> </mtext><mn>1</mn><mtext> </mtext><mn>3</mn><mtext> </mtext><mn>1</mn><mtext> </mtext><mn>4</mn><mtext> </mtext><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mtext> </mtext><mn>1</mn><mtext> </mtext><mi>n</mi><mtext> </mtext><mn>2</mn><mtext> </mtext><mn>3</mn><mtext> </mtext><mn>2</mn><mtext> </mtext><mn>4</mn><mtext> </mtext><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mtext> </mtext><mn>2</mn><mtext> </mtext><mi>n</mi><mtext> </mtext><mn>3</mn><mtext> </mtext><mn>4</mn><mtext> </mtext><mn>3</mn><mtext> </mtext><mn>5</mn><mtext> </mtext><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mtext> </mtext><mn>3</mn><mtext> </mtext><mi>n</mi><mtext> </mtext><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mtext> </mtext><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mtext> </mtext><mi>n</mi><mo>−</mo><mn>1</mn><mtext> </mtext><mi>n</mi><mtext> </mtext><mn>1</mn></mrow><annotation encoding="application/x-tex">n : 1\space 2\space 1\space 3\space 1\space 4\space ...\space 1\space n\space 2\space 3\space 2\space 4\space ...\space 2\space n\space 3\space 4\space 3\space 5\space ...\space 3\space n\space ...\space ...\space n-1\space n\space 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mspace"> </span><span class="mord">2</span><span class="mspace"> </span><span class="mord">1</span><span class="mspace"> </span><span class="mord">3</span><span class="mspace"> </span><span class="mord">1</span><span class="mspace"> </span><span class="mord">4</span><span class="mspace"> </span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mspace"> </span><span class="mord">1</span><span class="mspace"> </span><span class="mord mathdefault">n</span><span class="mspace"> </span><span class="mord">2</span><span class="mspace"> </span><span class="mord">3</span><span class="mspace"> </span><span class="mord">2</span><span class="mspace"> </span><span class="mord">4</span><span class="mspace"> </span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mspace"> </span><span class="mord">2</span><span class="mspace"> </span><span class="mord mathdefault">n</span><span class="mspace"> </span><span class="mord">3</span><span class="mspace"> </span><span class="mord">4</span><span class="mspace"> </span><span class="mord">3</span><span class="mspace"> </span><span class="mord">5</span><span class="mspace"> </span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mspace"> </span><span class="mord">3</span><span class="mspace"> </span><span class="mord mathdefault">n</span><span class="mspace"> </span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mspace"> </span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mspace"> </span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mspace"> </span><span class="mord mathdefault">n</span><span class="mspace"> </span><span class="mord">1</span></span></span></span></p>
<p>关键在于如何确定 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>[</mo><mi>l</mi><mo separator="true">,</mo><mi>r</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">[l, r]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mclose">]</span></span></span></span> 内的序列 , 换言之 , 给定下标 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> , 求出在序列中对应的值。</p>
<p>撇开最后一个 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 不谈。</p>
<p>考虑奇数位 , 有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 个 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>  , <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>−</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">n-2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span> 个 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span> , <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">...</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.10556em;vertical-align:0em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span></span></span></span>  , <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 个 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 。</p>
<p>考虑偶数位 , 有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn><mtext> </mtext><mn>3</mn><mtext> </mtext><mn>4</mn><mtext> </mtext><mn>5</mn><mtext> </mtext><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mtext> </mtext><mi>n</mi><mtext> </mtext><mn>3</mn><mtext> </mtext><mn>4</mn><mtext> </mtext><mn>5</mn><mtext> </mtext><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mtext> </mtext><mi>n</mi><mtext> </mtext><mn>4</mn><mtext> </mtext><mn>5</mn><mtext> </mtext><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mtext> </mtext><mi>n</mi><mtext> </mtext><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mtext> </mtext><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mtext> </mtext><mi>n</mi><mo>−</mo><mn>1</mn><mtext> </mtext><mi>n</mi></mrow><annotation encoding="application/x-tex">2\space 3\space 4\space 5\space ...\space n\space 3\space 4\space 5\space ...\space n\space 4\space 5\space ...\space n\space ...\space ...\space n-1\space n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mspace"> </span><span class="mord">3</span><span class="mspace"> </span><span class="mord">4</span><span class="mspace"> </span><span class="mord">5</span><span class="mspace"> </span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mspace"> </span><span class="mord mathdefault">n</span><span class="mspace"> </span><span class="mord">3</span><span class="mspace"> </span><span class="mord">4</span><span class="mspace"> </span><span class="mord">5</span><span class="mspace"> </span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mspace"> </span><span class="mord mathdefault">n</span><span class="mspace"> </span><span class="mord">4</span><span class="mspace"> </span><span class="mord">5</span><span class="mspace"> </span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mspace"> </span><span class="mord mathdefault">n</span><span class="mspace"> </span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mspace"> </span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mspace"> </span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mspace"> </span><span class="mord mathdefault">n</span></span></span></span> 注意到每一组的长度也为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>−</mo><mn>1</mn><mtext> </mtext><mi>n</mi><mo>−</mo><mn>2</mn><mtext> </mtext><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mtext> </mtext><mn>1</mn></mrow><annotation encoding="application/x-tex">n-1\space n-2\space ...\space 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mspace"> </span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mspace"> </span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mspace"> </span><span class="mord">1</span></span></span></span> 。</p>
<p>因此预处理数列 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>−</mo><mn>1</mn><mtext> </mtext><mi>n</mi><mo>−</mo><mn>2</mn><mtext> </mtext><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mtext> </mtext><mn>1</mn></mrow><annotation encoding="application/x-tex">n-1\space n-2\space ...\space 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mspace"> </span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mspace"> </span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mspace"> </span><span class="mord">1</span></span></span></span> 的前缀和 , 用原下标在奇数/偶数数列中对应的下标在该数列中二分查找即可定位。</p>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
#define rep(i,a,b) for(int i=a;i&lt;=(b);++i)
#define per(i,a,b) for(int i=a;i&gt;=(b);--i)
#define repp(i,a,b) for(int i=a;i&lt;(b);++i)
#define perr(i,a,b) for(int i=a;i&gt;(b);--i)
#define pb push_back
#define rz resize

using namespace std;

typedef long long ll;

const int inf = 0x3f3f3f3f, maxn = 123456;
const ll linf = 0x3f3f3f3f3f3f3f3f;

ll a[maxn], b[maxn];

ll tobound(ll l, ll r, ll key) {
	while(l &lt; r) {
		int mid = (l + r) &gt;&gt; 1;
		if(a[mid] &gt;= key) r = mid;
		else l = mid + 1;	
	}
	return l;
}

ll gen(ll n, ll idx) {
	if(idx == n*(n-1) + 1) return 1;
	if(idx % 2 == 1) {
		idx = idx / 2 + 1;
		return tobound(1, n - 1, idx);
	} else {
		idx /= 2;
		int blk = tobound(0, n - 1, idx);
		idx -= a[blk-1];
		return n - (a[blk] - a[blk-1]) + idx;
	}
}
int main() {
	int tests;
	cin&gt;&gt;tests;
	while(tests--) {
		ll n, l, r;
		cin &gt;&gt; n &gt;&gt; l &gt;&gt; r;
		rep(i,1,n) a[i] = n - i, a[i] += a[i-1];
		for(ll i = l; i &lt;= r; ++i) {
			cout &lt;&lt; gen(n, i) &lt;&lt; ' ';
		}
		cout &lt;&lt; endl;
	}
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[题解 P4655 【[CEOI2017]Building Bridges】]]></title>
        <id>https://froldh.github.io/post/ti-jie-p4655-ceoi2017building-bridges/</id>
        <link href="https://froldh.github.io/post/ti-jie-p4655-ceoi2017building-bridges/">
        </link>
        <updated>2020-04-05T02:30:50.000Z</updated>
        <summary type="html"><![CDATA[<p>题外话： 前几天神tommy教了李超线段树。</p>
]]></summary>
        <content type="html"><![CDATA[<p>题外话： 前几天神tommy教了李超线段树。</p>
<!-- more -->  
<p>考虑暴力dp， 设<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">f_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>为打通到第<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>号节点的最小代价, 有</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle scriptlevel="0" displaystyle="true"><msub><mi>f</mi><mi>i</mi></msub><mo>=</mo><munder><mi>min</mi><mo>⁡</mo><mrow><mn>1</mn><mo>⩽</mo><mi>j</mi><mo>&lt;</mo><mi>i</mi></mrow></munder><mo>{</mo><msub><mi>f</mi><mi>j</mi></msub><mo>+</mo><munderover><mo>∑</mo><mrow><mi>k</mi><mo>=</mo><mi>j</mi><mo>+</mo><mn>1</mn></mrow><mi>i</mi></munderover><msub><mi>w</mi><mi>k</mi></msub><mo>+</mo><mo>(</mo><msub><mi>h</mi><mi>i</mi></msub><mo>−</mo><msub><mi>h</mi><mi>j</mi></msub><msup><mo>)</mo><mn>2</mn></msup><mo>}</mo></mstyle></mrow><annotation encoding="application/x-tex">\displaystyle f_i = \min\limits_{1 \leqslant j &lt; i}\{f_j + \sum_{k=j+1}^i w_k + (h_i-h_j)^2\}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.613772em;vertical-align:-0.863772em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.66786em;"><span style="top:-2.0723360000000004em;margin-left:0em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mrel amsrm mtight">⩽</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mrel mtight">&lt;</span><span class="mord mathdefault mtight">i</span></span></span></span><span style="top:-2.7em;"><span class="pstrut" style="height:2.7em;"></span><span><span class="mop">min</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.863772em;"><span></span></span></span></span></span><span class="mopen">{</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:3.24989em;vertical-align:-1.438221em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.8116690000000002em;"><span style="top:-1.8478869999999998em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mrel mtight">=</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.0500049999999996em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.300005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.438221em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.150216em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">}</span></span></span></span></span></p>
<p>记<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>S</mi><mi>i</mi></msub><mo>=</mo><msubsup><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></msubsup><msub><mi>w</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">S_i = \sum_{i=1}^n w_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.104002em;vertical-align:-0.29971000000000003em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.804292em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.29971000000000003em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>, 变形式子</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mi>i</mi></msub><mo>=</mo><msubsup><mi>h</mi><mi>i</mi><mn>2</mn></msubsup><mo>+</mo><msub><mi>S</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>+</mo><munder><mi>min</mi><mo>⁡</mo><mrow><mn>1</mn><mo>⩽</mo><mi>j</mi><mo>&lt;</mo><mi>i</mi></mrow></munder><mo>{</mo><mo>−</mo><mn>2</mn><msub><mi>h</mi><mi>j</mi></msub><msub><mi>h</mi><mi>i</mi></msub><mo>+</mo><msub><mi>f</mi><mi>j</mi></msub><mo>+</mo><msubsup><mi>h</mi><mi>j</mi><mn>2</mn></msubsup><mo>−</mo><msub><mi>S</mi><mi>j</mi></msub><mo>}</mo></mrow><annotation encoding="application/x-tex">f_i = h_i^2+S_{i-1}+\min\limits_{1 \leqslant j &lt; i}\{-2h_jh_i+f_j+h_j^2-S_j\}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.1111079999999998em;vertical-align:-0.247em;"></span><span class="mord"><span class="mord mathdefault">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-2.4530000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.891661em;vertical-align:-0.208331em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.613772em;vertical-align:-0.863772em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.66786em;"><span style="top:-2.0723360000000004em;margin-left:0em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mrel amsrm mtight">⩽</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mrel mtight">&lt;</span><span class="mord mathdefault mtight">i</span></span></span></span><span style="top:-2.7em;"><span class="pstrut" style="height:2.7em;"></span><span><span class="mop">min</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.863772em;"><span></span></span></span></span></span><span class="mopen">{</span><span class="mord">−</span><span class="mord">2</span><span class="mord"><span class="mord mathdefault">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.2472159999999999em;vertical-align:-0.383108em;"></span><span class="mord"><span class="mord mathdefault">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.864108em;"><span style="top:-2.4530000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span><span style="top:-3.1130000000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.383108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mclose">}</span></span></span></span></span></p>
<p>每个<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>h</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">h_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>都会对后面的所有<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>h</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">h_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>进行更新, 这是一个关于<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>h</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">h_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的一次函数， <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi><mo>=</mo><mo>−</mo><mn>2</mn><msub><mi>h</mi><mi>j</mi></msub><mo separator="true">,</mo><mtext> </mtext><mi>b</mi><mo>=</mo><msub><mi>f</mi><mi>j</mi></msub><mo>+</mo><msubsup><mi>h</mi><mi>j</mi><mn>2</mn></msubsup><mo>−</mo><msub><mi>S</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">k=-2h_j, \space b = f_j + h_j^2-S_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord">−</span><span class="mord">2</span><span class="mord"><span class="mord mathdefault">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace"> </span><span class="mord mathdefault">b</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.20888em;vertical-align:-0.394772em;"></span><span class="mord"><span class="mord mathdefault">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-2.441336em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.394772em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>。<br>
用李超线段树即可维护即可在<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="script">O</mi><mo>(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O(\log n)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></span>求出单点的函数最值。<br>
复杂度<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="script">O</mi><mo>(</mo><mi>n</mi><mi>log</mi><mo>⁡</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O(n \log n)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></span></p>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
#define endl '\n'
#define rep(i,a,b) for(int i=a;i&lt;=(b);++i)
#define per(i,a,b) for(int i=a;i&gt;=(b);--i)
#define repp(i,a,b) for(int i=a;i&lt;(b);++i)
#define perr(i,a,b) for(int i=a;i&gt;(b);--i)

using namespace std;

typedef long long ll;

const int inf = 0x3f3f3f3f, maxn = 123456, maxh = 1234567;
const ll linf = 0x3f3f3f3f3f3f3f3f;

ll h[maxn], k[maxn], b[maxn], s[maxn], f[maxn];

int dat[maxh &lt;&lt; 2];

inline ll calc(int id, int x) {
	return k[id] * x + b[id];
}

void insert(int p, int lp, int rp, int id) {
	if(!dat[p]) { dat[p] = id; return; }
	if(lp == rp) {
		if(calc(dat[p], lp) &gt; calc(id, lp)) dat[p] = lp;
		return;
	}
	int mid = lp + rp &gt;&gt; 1;
	ll pre = calc(dat[p], mid), cur = calc(id, mid);
	if(k[dat[p]] &lt; k[id]) {
		if(cur &lt; pre) insert(p&lt;&lt;1|1, mid+1, rp, dat[p]), dat[p] = id;
		else insert(p&lt;&lt;1, lp, mid, id);
	} else if(k[dat[p]] &gt; k[id]) {
		if(cur &lt; pre) insert(p&lt;&lt;1, lp, mid, dat[p]), dat[p] = id;
		else insert(p&lt;&lt;1|1, mid+1, rp, id);
	} else {
		if(cur &lt; pre) dat[p] = id;
	}
}

ll qry(int p, int lp, int rp, int x) {
	if(lp == rp) return calc(dat[p], x);
	int mid = lp + rp &gt;&gt; 1;
	if(x &lt;= mid) return min(calc(dat[p], x), qry(p&lt;&lt;1, lp, mid, x));
	else return min(calc(dat[p], x), qry(p&lt;&lt;1|1, mid+1, rp, x));
}

int main() {
	ios::sync_with_stdio(false);
	cin.tie(0);
	int n;
	ll mh = 0;
	cin &gt;&gt; n;
	rep(i, 1, n) cin &gt;&gt; h[i], mh = max(h[i], mh);
	rep(i, 1, n) cin &gt;&gt; s[i];
	rep(i, 2, n) s[i] += s[i-1];
	k[0] = b[0] = inf;
	f[1] = 0;
	k[1] = -2 * h[1], b[1] = -s[1] + h[1]*h[1];
	insert(1, 0, mh, 1);
	rep(i, 2, n) {
		f[i] = h[i] * h[i] + s[i-1] + qry(1, 0, mh, h[i]);
		k[i] = -2 * h[i], b[i] = f[i] + -s[i] + h[i] * h[i];
		insert(1, 0, mh, i);
	}
	cout &lt;&lt; f[n] &lt;&lt; endl;
	return 0;
}
</code></pre>
]]></content>
    </entry>
</feed>