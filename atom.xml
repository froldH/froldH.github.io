<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://froldh.github.io</id>
    <title>oldherd&apos;s blog</title>
    <updated>2020-03-11T08:07:17.411Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://froldh.github.io"/>
    <link rel="self" href="https://froldh.github.io/atom.xml"/>
    <subtitle>又弱又笨的蒟蒻的博客</subtitle>
    <logo>https://froldh.github.io/images/avatar.png</logo>
    <icon>https://froldh.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, oldherd&apos;s blog</rights>
    <entry>
        <title type="html"><![CDATA[笔记 自适应辛普森积分]]></title>
        <id>https://froldh.github.io/post/bi-ji-zi-shi-ying-xin-pu-sen-ji-fen/</id>
        <link href="https://froldh.github.io/post/bi-ji-zi-shi-ying-xin-pu-sen-ji-fen/">
        </link>
        <updated>2020-03-09T06:09:30.000Z</updated>
        <summary type="html"><![CDATA[<p>辛普森积分用于计算<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle scriptlevel="0" displaystyle="true"><mrow><msubsup><mo>∫</mo><mi>a</mi><mi>b</mi></msubsup><mi>f</mi><mo>(</mo><mi>x</mi><mo>)</mo><mi>d</mi><mi>x</mi></mrow></mstyle></mrow><annotation encoding="application/x-tex">\displaystyle \mathcal{\int_{a}^{b}f(x)dx}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.5109580000000005em;vertical-align:-0.9119499999999999em;"></span><span class="mord"><span class="mop"><span class="mop op-symbol large-op" style="margin-right:0.44445em;position:relative;top:-0.0011249999999999316em;">∫</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.5990080000000004em;"><span style="top:-1.7880500000000001em;margin-left:-0.44445em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">a</span></span></span></span><span style="top:-3.812900000000001em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">b</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9119499999999999em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mord mathdefault">d</span><span class="mord mathdefault">x</span></span></span></span></span>。</p>
]]></summary>
        <content type="html"><![CDATA[<p>辛普森积分用于计算<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle scriptlevel="0" displaystyle="true"><mrow><msubsup><mo>∫</mo><mi>a</mi><mi>b</mi></msubsup><mi>f</mi><mo>(</mo><mi>x</mi><mo>)</mo><mi>d</mi><mi>x</mi></mrow></mstyle></mrow><annotation encoding="application/x-tex">\displaystyle \mathcal{\int_{a}^{b}f(x)dx}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.5109580000000005em;vertical-align:-0.9119499999999999em;"></span><span class="mord"><span class="mop"><span class="mop op-symbol large-op" style="margin-right:0.44445em;position:relative;top:-0.0011249999999999316em;">∫</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.5990080000000004em;"><span style="top:-1.7880500000000001em;margin-left:-0.44445em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">a</span></span></span></span><span style="top:-3.812900000000001em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">b</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9119499999999999em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mord mathdefault">d</span><span class="mord mathdefault">x</span></span></span></span></span>。</p>
<!--more-->  
<h3 id="前置知识">前置知识</h3>
<h4 id="定积分的概念">定积分的概念</h4>
<p>定积分表示函数<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>(</mo><mi>x</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">f(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span>在某个区间上的极限和, 直观地讲, 它表示在二维平面上函数曲线、直线、x轴围成的曲边梯形的面积大小。</p>
<h4 id="积分的可加性">积分的可加性</h4>
<p>若<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>(</mo><mi>x</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">f(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span>在区间<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>[</mo><mi>a</mi><mo separator="true">,</mo><mi>c</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">[a, c]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">c</span><span class="mclose">]</span></span></span></span>上是可积的, 且<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo>⩽</mo><mi>b</mi><mo>⩽</mo><mi>c</mi></mrow><annotation encoding="application/x-tex">a \leqslant b \leqslant c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7733399999999999em;vertical-align:-0.13667em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel amsrm">⩽</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.83111em;vertical-align:-0.13667em;"></span><span class="mord mathdefault">b</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel amsrm">⩽</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">c</span></span></span></span>, 则有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle scriptlevel="0" displaystyle="true"><mrow><msubsup><mo>∫</mo><mi>a</mi><mi>b</mi></msubsup><mi>f</mi><mo>(</mo><mi>x</mi><mo>)</mo><mi>d</mi><mi>x</mi></mrow><mo>+</mo><mstyle scriptlevel="0" displaystyle="true"><mrow><msubsup><mo>∫</mo><mi>b</mi><mi>c</mi></msubsup><mi>f</mi><mo>(</mo><mi>x</mi><mo>)</mo><mi>d</mi><mi>x</mi></mrow><mo>=</mo><mstyle scriptlevel="0" displaystyle="true"><mrow><msubsup><mo>∫</mo><mi>a</mi><mi>c</mi></msubsup><mi>f</mi><mo>(</mo><mi>x</mi><mo>)</mo><mi>d</mi><mi>x</mi></mrow></mstyle></mstyle></mstyle></mrow><annotation encoding="application/x-tex">\displaystyle \mathcal{\int_{a}^{b}f(x)dx} + \displaystyle \mathcal{\int_{b}^{c}f(x)dx} = \displaystyle \mathcal{\int_{a}^{c}f(x)dx}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.5109580000000005em;vertical-align:-0.9119499999999999em;"></span><span class="mord"><span class="mop"><span class="mop op-symbol large-op" style="margin-right:0.44445em;position:relative;top:-0.0011249999999999316em;">∫</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.5990080000000004em;"><span style="top:-1.7880500000000001em;margin-left:-0.44445em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">a</span></span></span></span><span style="top:-3.812900000000001em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">b</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9119499999999999em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mord mathdefault">d</span><span class="mord mathdefault">x</span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:2.326242em;vertical-align:-0.9119499999999999em;"></span><span class="mord"><span class="mop"><span class="mop op-symbol large-op" style="margin-right:0.44445em;position:relative;top:-0.0011249999999999316em;">∫</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.414292em;"><span style="top:-1.7880500000000001em;margin-left:-0.44445em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">b</span></span></span></span><span style="top:-3.8129000000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">c</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9119499999999999em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mord mathdefault">d</span><span class="mord mathdefault">x</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.3262420000000006em;vertical-align:-0.9119499999999999em;"></span><span class="mord"><span class="mop"><span class="mop op-symbol large-op" style="margin-right:0.44445em;position:relative;top:-0.0011249999999999316em;">∫</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.4142920000000005em;"><span style="top:-1.7880500000000001em;margin-left:-0.44445em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">a</span></span></span></span><span style="top:-3.812900000000001em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">c</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9119499999999999em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mord mathdefault">d</span><span class="mord mathdefault">x</span></span></span></span></span></p>
<h3 id="三点辛普森值">三点辛普森值</h3>
<p>对于一个自变量区间<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>[</mo><mi>l</mi><mo separator="true">,</mo><mi>r</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">[l, r]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mclose">]</span></span></span></span>, 我们将<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle scriptlevel="0" displaystyle="true"><mfrac><mrow><mi>f</mi><mo>(</mo><mi>l</mi><mo>)</mo><mo>+</mo><mi>f</mi><mo>(</mo><mi>r</mi><mo>)</mo><mo>+</mo><mn>4</mn><mi>f</mi><mo>(</mo><mfrac><mrow><mi>l</mi><mo>+</mo><mi>r</mi></mrow><mn>2</mn></mfrac><mo>)</mo></mrow><mn>6</mn></mfrac></mstyle></mrow><annotation encoding="application/x-tex">\displaystyle \frac{f(l) + f(r) + 4f(\frac{l+r}{2})}{6}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.3011079999999997em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6151079999999998em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">6</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.7350000000000003em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">4</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8801079999999999em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mbin mtight">+</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>定义为其三点辛普森值。</p>
<h3 id="辛普森积分与辛普森法">辛普森积分与辛普森法</h3>
<p>辛普森积分认为, 当<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>b</mi><mo>−</mo><mi>a</mi></mrow><annotation encoding="application/x-tex">b - a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">b</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span></span></span></span>趋向<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>的时候，某函数在<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>[</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">[a, b]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span><span class="mclose">]</span></span></span></span>上的积分近似于其三点辛普森值常函数在这个区间上的积分。即<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle scriptlevel="0" displaystyle="true"><msubsup><mo>∫</mo><mi>a</mi><mi>b</mi></msubsup><mi>f</mi><mo>(</mo><mi>x</mi><mo>)</mo><mi>d</mi><mi>x</mi><mo>≐</mo><mo>(</mo><mi>r</mi><mo>−</mo><mi>l</mi><mo>)</mo><mfrac><mrow><mi>f</mi><mo>(</mo><mi>l</mi><mo>)</mo><mo>+</mo><mi>f</mi><mo>(</mo><mi>r</mi><mo>)</mo><mo>+</mo><mi>f</mi><mo>(</mo><mfrac><mrow><mi>l</mi><mo>+</mo><mi>r</mi></mrow><mn>2</mn></mfrac><mo>)</mo></mrow><mn>6</mn></mfrac></mstyle></mrow><annotation encoding="application/x-tex">\displaystyle \int_{a}^{b}f(x)dx \doteq (r-l)\frac{f(l) + f(r) + f(\frac{l+r}{2})}{6}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.5109580000000005em;vertical-align:-0.9119499999999999em;"></span><span class="mop"><span class="mop op-symbol large-op" style="margin-right:0.44445em;position:relative;top:-0.0011249999999999316em;">∫</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.5990080000000004em;"><span style="top:-1.7880500000000001em;margin-left:-0.44445em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">a</span></span></span></span><span style="top:-3.812900000000001em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">b</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9119499999999999em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mord mathdefault">d</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≐</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:2.3011079999999997em;vertical-align:-0.686em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mclose">)</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6151079999999998em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">6</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.7350000000000003em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8801079999999999em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mbin mtight">+</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>。其中<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle scriptlevel="0" displaystyle="true"><mo>(</mo><mi>r</mi><mo>−</mo><mi>l</mi><mo>)</mo><mfrac><mrow><mi>f</mi><mo>(</mo><mi>l</mi><mo>)</mo><mo>+</mo><mi>f</mi><mo>(</mo><mi>r</mi><mo>)</mo><mo>+</mo><mi>f</mi><mo>(</mo><mfrac><mrow><mi>l</mi><mo>+</mo><mi>r</mi></mrow><mn>2</mn></mfrac><mo>)</mo></mrow><mn>6</mn></mfrac></mstyle></mrow><annotation encoding="application/x-tex">\displaystyle (r-l)\frac{f(l) + f(r) + f(\frac{l+r}{2})}{6}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:2.3011079999999997em;vertical-align:-0.686em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mclose">)</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6151079999999998em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">6</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.7350000000000003em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8801079999999999em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mbin mtight">+</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>称为辛普森积分值。故可以将原区间等分为很多小段, 求出辛普森积分值然后相加得到积分的近似值。平均情况下，划分的小段长度越短, 用这个方法求得的近似值与原值越接近, 该方法精度越高。<br>
但是这样做会遇到问题, 我们并不知道划分为多少段才能够达到我们要求的精度。在有些函数上, 并不需要划分得过密, 例如一次函数无论划分多少段其辛普森积分值都严格等于该函数的积分值, 在某些二阶导数很大(即“变化”程度很大)的函数上则需要划分很多段才能取得较高精度的近似解。此外, 在同一函数上的“变化”程度也会不同。这意味着, 笼统的划分一方面将使我们在许多不必要的地方浪费时间(并且过度划分可能会因为浮点数运算过多降低精度), 另一方面在必要的地方计算不足而使得结果的精度不高。</p>
<h3 id="自适应辛普森法">自适应辛普森法</h3>
<p>好在辛普森法有一个“自适应”的版本。<br>
我们记<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi><mo>(</mo><mi>l</mi><mo separator="true">,</mo><mi>r</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">S(l, r)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mclose">)</span></span></span></span>为区间<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>[</mo><mi>l</mi><mo separator="true">,</mo><mi>r</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">[l, r]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mclose">]</span></span></span></span>上的辛普森积分值。如果<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">∣</mi><mi>S</mi><mo>(</mo><mi>l</mi><mo separator="true">,</mo><mfrac><mrow><mi>l</mi><mo>+</mo><mi>r</mi></mrow><mn>2</mn></mfrac><mo>)</mo><mo>+</mo><mi>S</mi><mo>(</mo><mfrac><mrow><mi>l</mi><mo>+</mo><mi>r</mi></mrow><mn>2</mn></mfrac><mo separator="true">,</mo><mi>r</mi><mo>)</mo><mo>−</mo><mi>S</mi><mo>(</mo><mi>l</mi><mo separator="true">,</mo><mi>r</mi><mo>)</mo><mi mathvariant="normal">∣</mi><mo>⩽</mo><mn>15</mn><mi>e</mi><mi>p</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">|S(l, \frac{l+r}{2}) + S(\frac{l+r}{2}, r) - S(l, r)| \leqslant 15eps</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2251079999999999em;vertical-align:-0.345em;"></span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8801079999999999em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mbin mtight">+</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.2251079999999999em;vertical-align:-0.345em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mopen">(</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8801079999999999em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mbin mtight">+</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mclose">)</span><span class="mord">∣</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel amsrm">⩽</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord">1</span><span class="mord">5</span><span class="mord mathdefault">e</span><span class="mord mathdefault">p</span><span class="mord mathdefault">s</span></span></span></span>, 我们认为这个划分在精度<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>e</mi><mi>p</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">eps</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">e</span><span class="mord mathdefault">p</span><span class="mord mathdefault">s</span></span></span></span>下取得的辛普森积分值等于原来函数的积分值。<br>
那么算法的流程就清晰了, 如果精度足够就直接返回辛普森积分值, 如果精度不够, 就不断递归进行划分, 直到精度足够。</p>
<p>注意点:</p>
<ol>
<li>实际上double计算时也会有误差, 所以一般把精度设得更高一些。</li>
<li>向下递归时, <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>e</mi><mi>p</mi><mi>s</mi><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">eps / 2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">e</span><span class="mord mathdefault">p</span><span class="mord mathdefault">s</span><span class="mord">/</span><span class="mord">2</span></span></span></span>。</li>
<li>由经验规律, 通常在精度足够时将返回值加上<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mrow><mi>S</mi><mo>(</mo><mi>l</mi><mo separator="true">,</mo><mfrac><mrow><mi>l</mi><mo>+</mo><mi>r</mi></mrow><mn>2</mn></mfrac><mo>)</mo><mo>+</mo><mi>S</mi><mo>(</mo><mfrac><mrow><mi>l</mi><mo>+</mo><mi>r</mi></mrow><mn>2</mn></mfrac><mo separator="true">,</mo><mi>r</mi><mo>)</mo><mo>−</mo><mi>S</mi><mo>(</mo><mi>l</mi><mo separator="true">,</mo><mi>r</mi><mo>)</mo></mrow><mn>15</mn></mfrac></mrow><annotation encoding="application/x-tex">\frac{S(l, \frac{l+r}{2}) + S(\frac{l+r}{2}, r) - S(l, r)}{15}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.51182em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.16682em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">5</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.5508em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05764em;">S</span><span class="mopen mtight">(</span><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mpunct mtight">,</span><span class="mord mtight"><span class="mopen nulldelimiter sizing reset-size3 size6"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8800285714285714em;"><span style="top:-2.656em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.2255000000000003em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line mtight" style="border-bottom-width:0.049em;"></span></span><span style="top:-3.384em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mbin mtight">+</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.344em;"><span></span></span></span></span></span><span class="mclose nulldelimiter sizing reset-size3 size6"></span></span><span class="mclose mtight">)</span><span class="mbin mtight">+</span><span class="mord mathdefault mtight" style="margin-right:0.05764em;">S</span><span class="mopen mtight">(</span><span class="mord mtight"><span class="mopen nulldelimiter sizing reset-size3 size6"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8800285714285714em;"><span style="top:-2.656em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.2255000000000003em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line mtight" style="border-bottom-width:0.049em;"></span></span><span style="top:-3.384em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mbin mtight">+</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.344em;"><span></span></span></span></span></span><span class="mclose nulldelimiter sizing reset-size3 size6"></span></span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span><span class="mclose mtight">)</span><span class="mbin mtight">−</span><span class="mord mathdefault mtight" style="margin-right:0.05764em;">S</span><span class="mopen mtight">(</span><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>, 即<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi><mo>(</mo><mi>l</mi><mo separator="true">,</mo><mfrac><mrow><mi>l</mi><mo>+</mo><mi>r</mi></mrow><mn>2</mn></mfrac><mo>)</mo><mo>+</mo><mi>S</mi><mo>(</mo><mfrac><mrow><mi>l</mi><mo>+</mo><mi>r</mi></mrow><mn>2</mn></mfrac><mo separator="true">,</mo><mi>r</mi><mo>)</mo><mo>+</mo><mfrac><mrow><mi>S</mi><mo>(</mo><mi>l</mi><mo separator="true">,</mo><mfrac><mrow><mi>l</mi><mo>+</mo><mi>r</mi></mrow><mn>2</mn></mfrac><mo>)</mo><mo>+</mo><mi>S</mi><mo>(</mo><mfrac><mrow><mi>l</mi><mo>+</mo><mi>r</mi></mrow><mn>2</mn></mfrac><mo separator="true">,</mo><mi>r</mi><mo>)</mo><mo>−</mo><mi>S</mi><mo>(</mo><mi>l</mi><mo separator="true">,</mo><mi>r</mi><mo>)</mo></mrow><mn>15</mn></mfrac></mrow><annotation encoding="application/x-tex">S(l, \frac{l+r}{2}) + S(\frac{l+r}{2}, r) + \frac{S(l, \frac{l+r}{2}) + S(\frac{l+r}{2}, r) - S(l, r)}{15}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2251079999999999em;vertical-align:-0.345em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8801079999999999em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mbin mtight">+</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.2251079999999999em;vertical-align:-0.345em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mopen">(</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8801079999999999em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mbin mtight">+</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.51182em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.16682em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">5</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.5508em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05764em;">S</span><span class="mopen mtight">(</span><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mpunct mtight">,</span><span class="mord mtight"><span class="mopen nulldelimiter sizing reset-size3 size6"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8800285714285714em;"><span style="top:-2.656em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.2255000000000003em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line mtight" style="border-bottom-width:0.049em;"></span></span><span style="top:-3.384em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mbin mtight">+</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.344em;"><span></span></span></span></span></span><span class="mclose nulldelimiter sizing reset-size3 size6"></span></span><span class="mclose mtight">)</span><span class="mbin mtight">+</span><span class="mord mathdefault mtight" style="margin-right:0.05764em;">S</span><span class="mopen mtight">(</span><span class="mord mtight"><span class="mopen nulldelimiter sizing reset-size3 size6"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8800285714285714em;"><span style="top:-2.656em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.2255000000000003em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line mtight" style="border-bottom-width:0.049em;"></span></span><span style="top:-3.384em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mbin mtight">+</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.344em;"><span></span></span></span></span></span><span class="mclose nulldelimiter sizing reset-size3 size6"></span></span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span><span class="mclose mtight">)</span><span class="mbin mtight">−</span><span class="mord mathdefault mtight" style="margin-right:0.05764em;">S</span><span class="mopen mtight">(</span><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></li>
</ol>
<h3 id="板子代码">板子代码</h3>
<p>(Luogu P4525)</p>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;

using namespace std;

typedef long long ll;

double a, b, c, d;
inline double f(double x) { // 原函数求值, 可替换
	return (c * x + d) / (a * x + b);
}

inline double simpson(double l, double r) {
	return (f(l) + 4 * f(0.5*(l+r)) + f(r)) * (r - l) / 6;
}

double asr(double l, double r, double eps, double la) {
	double mid = 0.5 * (l + r);
	double ls = simpson(l, mid), rs = simpson(mid, r);
	if(abs(ls + rs - la) &lt;= 15 * eps) return ls + rs + (rs + ls - la) / 15;
	return asr(l, mid, eps * 0.5, ls) + asr(mid, r, eps * 0.5, rs);
}

int main() {
	ios::sync_with_stdio(false);
	cin.tie(0);
	double l, r;
	cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d &gt;&gt; l &gt;&gt; r;
	cout.setf(ios::fixed);
	cout.precision(6);
	cout &lt;&lt; asr(l, r, 1e-6, simpson(l, r)) &lt;&lt; '\n';
	return 0;
}
</code></pre>
<p>(Luogu P4526)<br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo>&lt;</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">a &lt; 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>不收敛输出&quot;orz&quot;.<br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo>⩾</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">a \geqslant 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7733399999999999em;vertical-align:-0.13667em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel amsrm">⩾</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>收敛, 在自变量较大的地方趋近于0直接忽略掉, 跑simpson即可。</p>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;

using namespace std;

typedef long long ll;

double a;
inline double f(double x) {
	return pow(x, a / x - x); 
}

inline double simpson(double l, double r) {
	return (f(l) + 4 * f(0.5*(l+r)) + f(r)) * (r - l) / 6;
}

double asr(double l, double r, double eps, double la) {
	double mid = 0.5 * (l + r);
	double ls = simpson(l, mid), rs = simpson(mid, r);
	if(abs(ls + rs - la) &lt;= 15 * eps) return ls + rs;
	return asr(l, mid, eps * 0.5, ls) + asr(mid, r, eps * 0.5, rs);
}

int main() {
	ios::sync_with_stdio(false);
	cin.tie(0);
	cin &gt;&gt; a;
	if(a &lt; 0) cout &lt;&lt; &quot;orz\n&quot;;
	else {
		cout.setf(ios::fixed);
		cout.precision(5);
		cout &lt;&lt; asr(1e-8, 20, 1e-8, simpson(1e-8, 20)) &lt;&lt; '\n';
	}
	return 0;
}
</code></pre>
<h3 id="习题">习题</h3>
<h4 id="1-hdu1724-ellipse">(1) HDU1724 Ellipse</h4>
<p>对一个中心在原点的椭圆, 求如图蓝色区域面积。<br>
<img src="https://froldh.github.io/post-images/1583804865537.jpg" alt="" loading="lazy"><br>
裸题, 由椭圆标准方程<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle scriptlevel="0" displaystyle="true"><mfrac><msup><mi>x</mi><mn>2</mn></msup><msup><mi>a</mi><mn>2</mn></msup></mfrac><mo>+</mo><mfrac><msup><mi>y</mi><mn>2</mn></msup><msup><mi>b</mi><mn>2</mn></msup></mfrac><mo>=</mo><mn>1</mn></mstyle></mrow><annotation encoding="application/x-tex">\displaystyle \frac{x^2}{a^2}+\frac{y^2}{b^2}=1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.177108em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.491108em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.740108em;"><span style="top:-2.9890000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:2.177108em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.491108em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.740108em;"><span style="top:-2.9890000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>化出上半边的式子<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle scriptlevel="0" displaystyle="true"><mi>y</mi><mo>=</mo><mi>b</mi><msqrt><mrow><mn>1</mn><mo>−</mo><mfrac><msup><mi>x</mi><mn>2</mn></msup><msup><mi>a</mi><mn>2</mn></msup></mfrac></mrow></msqrt></mstyle></mrow><annotation encoding="application/x-tex">\displaystyle y = b\sqrt{1-\frac{x^2}{a^2}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.44em;vertical-align:-0.7405709999999996em;"></span><span class="mord mathdefault">b</span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6994290000000003em;"><span class="svg-align" style="top:-4.4em;"><span class="pstrut" style="height:4.4em;"></span><span class="mord" style="padding-left:1em;"><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.417108em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.740108em;"><span style="top:-2.9890000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.740108em;"><span style="top:-2.9890000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span><span style="top:-3.6594290000000007em;"><span class="pstrut" style="height:4.4em;"></span><span class="hide-tail" style="min-width:1.02em;height:2.48em;"><svg width='400em' height='2.48em' viewBox='0 0 400000 2592' preserveAspectRatio='xMinYMin slice'><path d='M424,2478c-1.3,-0.7,-38.5,-172,-111.5,-514c-73,
-342,-109.8,-513.3,-110.5,-514c0,-2,-10.7,14.3,-32,49c-4.7,7.3,-9.8,15.7,-15.5,
25c-5.7,9.3,-9.8,16,-12.5,20s-5,7,-5,7c-4,-3.3,-8.3,-7.7,-13,-13s-13,-13,-13,
-13s76,-122,76,-122s77,-121,77,-121s209,968,209,968c0,-2,84.7,-361.7,254,-1079
c169.3,-717.3,254.7,-1077.7,256,-1081c4,-6.7,10,-10,18,-10H400000v40H1014.6
s-87.3,378.7,-272.6,1166c-185.3,787.3,-279.3,1182.3,-282,1185c-2,6,-10,9,-24,9
c-8,0,-12,-0.7,-12,-2z M1001 80H400000v40H1014z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.7405709999999996em;"><span></span></span></span></span></span></span></span></span>然后乘2即得面积。</p>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;

using namespace std;

typedef long long ll;

double a, b, a2;

double f(double x) {
	return 2 * b * sqrt(1 - (x*x) / a2);	
}

inline double simpson(double l, double r) {
	return (r - l) * (f(l) + f(r) + 4 * f(0.5 * (l + r))) / 6;
}

double asr(double l, double r, double eps, double la) {
	double mid = 0.5 * (l + r);
	double ls = simpson(l, mid), rs = simpson(mid, r);
	if(abs(ls + rs - la) &lt;= 15 * eps) return ls + rs + (ls + rs - la) / 15;
	return asr(l, mid, 0.5 * eps, ls) + asr(mid, r, 0.5 * eps, rs);
}

int main() {
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.setf(ios::fixed);
	cout.precision(3);
	double l, r;
	int n;
	cin &gt;&gt; n;
	while(n--) {
		cin &gt;&gt; a &gt;&gt; b &gt;&gt; l &gt;&gt; r;
		a2 = a * a;
		cout &lt;&lt; asr(l, r, 1e-5, simpson(l, r)) &lt;&lt; '\n';
	}
	return 0;
}
</code></pre>
<h4 id="2-bzoj-2178-圆的面积并">(2) BZOJ 2178  圆的面积并</h4>
<p>给定<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>个圆, <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>⩽</mo><mn>1000</mn></mrow><annotation encoding="application/x-tex">n \leqslant 1000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7733399999999999em;vertical-align:-0.13667em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel amsrm">⩽</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span>， 坐标范围在<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>[</mo><mo>−</mo><mn>1000</mn><mo separator="true">,</mo><mn>1000</mn><mo>]</mo></mrow><annotation encoding="application/x-tex">[-1000, 1000]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">−</span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mclose">]</span></span></span></span>。求圆的面积并。<br>
计算几何题, 按交点分割成多边形和弧形, 代码又臭又长。<br>
但是可以用simpson水过去。计算某个坐标上的所有圆的截线段并的长度作为函数值、将圆的横坐标覆盖的区间范围作为自变量的范围求积分相加即可。<br>
一个小trick: 实际上在之前的计算中同一个函数值被计算了很多次, 在这里函数值计算的代价很大, 考虑算出来之后把值记下来, 使每一个值只被算一遍。<br>
BZOJ好像有一组数据来卡这个做法, 限制一下递归层数, 大概强制递归10层就不会漏掉。</p>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;

using namespace std;

typedef long long ll;

struct circ {
	double x, y, r;
	circ(){}
	circ(int X, int Y, int R) : x(X), y(Y), r(R) {}
};

struct seg {
	double l, r;
	seg() {}
	seg(double L, double R) : l(L), r(R) {}
}sgs[1010];

circ circs[1010], tmp[1010];
int isen[1010], ed = 0;

double f(double x) {
	vector&lt;seg&gt; v;
	for(int i = 0; i &lt; ed; ++i) {
		circ&amp; cur = circs[i]; 
		if(cur.x - cur.r &lt; x &amp;&amp; cur.x + cur.r &gt; x) {
			double dl = sqrt(cur.r * cur.r - (cur.x-x) * (cur.x-x));
			v.push_back(seg(cur.y - dl, cur.y + dl));
		}
	} 
	if(v.empty()) return 0;
	sort(v.begin(), v.end(), [&amp;](seg a, seg b){ return a.l &lt; b.l; });
	double ans = v[0].r - v[0].l, nr = v[0].r;
	int vs = v.size(); 
	for(int i = 1; i &lt; vs; ++i)
		if(v[i].r &gt; nr) ans += v[i].r - max(nr, v[i].l), nr = v[i].r;
	return ans;
}

inline double simpson(double l, double r, double fl, double fmid, double fr) {
	return (r - l) * (fl + fr + 4 * fmid) / 6;
}

double asr(double l, double r, double fl, double fmid, double fr, double la, int d) {
	double mid = 0.5 * (l + r);
	double flmid = f(0.5*(l+mid)), frmid = f(0.5*(mid+r));
	double ls = simpson(l, mid, fl, flmid, fmid), rs = simpson(mid, r, fmid, frmid, fr);
	if(abs(ls + rs - la) &lt;= 1e-8 &amp;&amp; d &gt; 10) return la;
	return asr(l, mid, fl, flmid, fmid, ls, d+1) + asr(mid, r, fmid, frmid, fr, rs, d+1);
}

inline double dis2(double x1, double y1, double x2, double y2) {
	return (x1-x2)*(x1-x2) + (y1-y2)*(y1-y2);
}

int main() {
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.setf(ios::fixed);
	cout.precision(3);
	int n;
	double tx, ty, tr;
	cin &gt;&gt; n;
	for(int i = 0; i &lt; n; ++i) {
		cin &gt;&gt; tx &gt;&gt; ty &gt;&gt; tr;
		tmp[i] = circ(tx, ty, tr);
	}
	for(int i = 0; i &lt; n; ++i)
		for(int j = i + 1; j &lt; n; ++j) 
			if(dis2(tmp[i].x, tmp[i].y, tmp[j].x, tmp[j].y) &lt;= (tmp[i].r-tmp[j].r)*(tmp[i].r-tmp[j].r)) {
				if(tmp[i].r &lt; tmp[j].r) isen[i] = 1;
				else isen[j] = 1;
				break;
			}
	for(int i = 0; i &lt; n; ++i)
		if(!isen[i])
			circs[ed] = tmp[i], sgs[ed++] = seg(tmp[i].x-tmp[i].r, tmp[i].x+tmp[i].r);
	sort(sgs, sgs+ed, [&amp;](seg x, seg y){ return x.l &lt; y.l; });
	double l = sgs[0].l, r = sgs[0].r, ans;
	for(int i = 1; i &lt; ed; ++i) {
		if(sgs[i].l &gt; r) {
			double fl = f(l), fr = f(r), fmid = f(0.5*(l+r));
			ans	+= asr(l, r, fl, fmid, fr, simpson(l, r, fl, fmid, fr), 0);
			l = sgs[i].l, r = sgs[i].r;
		} else r = max(sgs[i].r, r);
	}
	double fl = f(l), fr = f(r), fmid = f(0.5*(l+r));
	ans	+= asr(l, r, fl, fmid, fr, simpson(l, r, fl, fmid, fr), 0);
	cout &lt;&lt; ans &lt;&lt; '\n';
	return 0;
}
</code></pre>
<h3 id="参考资料">参考资料</h3>
<p>刘汝佳 《算法竞赛入门经典(训练指南) 第2版》</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[题解 [起跑线]普及模拟Round5]]></title>
        <id>https://froldh.github.io/post/qpx-pj-round5/</id>
        <link href="https://froldh.github.io/post/qpx-pj-round5/">
        </link>
        <updated>2020-02-27T14:29:44.000Z</updated>
        <summary type="html"><![CDATA[<p>这场人均AK罢，T2挂了(鬼晓得有负数哦，时间够还去剪枝就是作死)<br>
Rnk12 300丢死人了</p>
]]></summary>
        <content type="html"><![CDATA[<p>这场人均AK罢，T2挂了(鬼晓得有负数哦，时间够还去剪枝就是作死)<br>
Rnk12 300丢死人了</p>
<!-- more -->
<h3 id="t1-解方程">T1 解方程</h3>
<p>取几个模数暴力就好了。听说自然溢出也能过？<br>
复杂度<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="script">O</mi><mo>(</mo><mi>n</mi><mi>r</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O(nr)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mclose">)</span></span></span></span></span></p>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;

using namespace std;

typedef long long ll;

const ll m1 = 998244353, m2 = 19260817, m3 = 1000000007;
vector&lt;ll&gt; a, ans;


int main() {
	ios::sync_with_stdio(false);
	cin.tie(0);
	int n, l, r, cnt = 0;
	cin &gt;&gt; n &gt;&gt; l &gt;&gt; r;
	a.resize(n + 1);
	for(int i = 0; i &lt;= n; ++i) cin &gt;&gt; a[i];
	for(int i = l; i &lt;= r; ++i) {
		ll t1 = 1, t2 = 1, t3 = 1, a1 = 0, a2 = 0, a3 = 0;
		for(int j = 0; j &lt;= n; ++j) {
			a1 = (a1 + (t1 * a[j]) % m1) % m1;
			a2 = (a2 + (t2 * a[j]) % m2) % m2;
			a3 = (a3 + (t3 * a[j]) % m3) % m3;
			t1 = t1 * i % m1;
			t2 = t2 * i % m2;
			t3 = t3 * i % m3;
		}
		if(a1 == 0 &amp;&amp; a2 == 0 &amp;&amp; a3 == 0) {
			ans.push_back(i);
			++cnt;
		}
	}
	cout &lt;&lt; cnt &lt;&lt; '\n';
	for(int i = 0; i &lt; cnt; ++i) cout &lt;&lt; ans[i] &lt;&lt; '\n';
	return 0;
}
</code></pre>
<h3 id="t2-求和问题">T2 求和问题</h3>
<p>暴力dfs。<br>
艹，竟然有负数，不要去用可行性剪枝。<br>
复杂度<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="script">O</mi><mo>(</mo><msup><mn mathvariant="script">2</mn><mi>n</mi></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O(2^n)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathcal">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span></p>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;

using namespace std;

typedef long long ll;

vector&lt;ll&gt; x;
ll ans;
int n, k, q;

void dfs(int cur, ll sum, int cnt) {
	if(cur == n) {
		if(sum == q &amp;&amp; k == cnt) ++ans;
		return;	
	}
	dfs(cur + 1, sum, cnt);
	if(cnt &lt; k)
		dfs(cur + 1, sum + x[cur], cnt + 1);
}

bool cmp(ll a, ll b) {
	return a &gt; b;	
}

int main() {
	ios::sync_with_stdio(false);
	cin.tie(0);
	cin &gt;&gt; n &gt;&gt; k &gt;&gt; q;
	x.resize(n);
	for(int i = 0; i &lt; n; ++i) {
		cin &gt;&gt; x[i];
	}
	sort(x.begin(), x.end(), cmp); 
	dfs(0, 0, 0);
	cout &lt;&lt; ans &lt;&lt; '\n';
	return 0;
}
</code></pre>
<h3 id="t3-集合">T3 集合</h3>
<p>先排序，枚举最小值，二分查最大值，中间的数都能选。<br>
复杂度<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="script">O</mi><mo>(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo>+</mo><mi>q</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O(nlogn + qlognlogn)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></span>(预处理2的幂表格应该是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="script">O</mi><mo>(</mo><mo>(</mo><mi>n</mi><mo>+</mo><mi>q</mi><mo>)</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O((n+q)logn)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="mclose">)</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></span>)</p>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;

using namespace std;

typedef long long ll;

const ll mod = 1000000007;

vector&lt;ll&gt; v;

int bsh(int l, int r, ll x) {
	while(l &lt; r) {
		int mid = (l + r + 1) &gt;&gt; 1;
		if(v[mid] &lt;= x) l = mid;
		else r = mid - 1;
	}
	return l;
}

ll qp(ll a, ll b) {
	ll res = 1 % mod;
	for(; b; b &gt;&gt;= 1) {
		if(b &amp; 1) res = res * a % mod;
		a = a * a % mod;
	}
	return res;
}

int main() {
	ios::sync_with_stdio(false);
	cin.tie(0);
	ll ans = 0;
	int n, k;
	cin &gt;&gt; n &gt;&gt; k;
	v.resize(n);
	for(int i = 0; i &lt; n; ++i) cin &gt;&gt; v[i];
	sort(v.begin(), v.end());
	for(int i = 0; i &lt; n; ++i) {
		int nxt = bsh(i, n - 1, v[i] + k);
		if(v[nxt] == v[i] + k) {
			ll len = nxt - i + 1 - 2;
			ans = (ans + qp(2, len)) % mod;
		}
	}
	cout &lt;&lt; ans &lt;&lt; '\n';
	return 0;
}
</code></pre>
<h3 id="t4-求和">T4 求和</h3>
<p>对于比较大的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>采用暴力求,为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="script">O</mi><mo>(</mo><mfrac><mi>n</mi><mi>k</mi></mfrac><mo>)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O(\frac{n}{k})}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.095em;vertical-align:-0.345em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.695392em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">)</span></span></span></span></span>。<br>
比较小的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>打个表预处理。<br>
当<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>取到<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msqrt><mi>n</mi></msqrt></mrow><annotation encoding="application/x-tex">\sqrt{n}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.04em;vertical-align:-0.23972em;"></span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8002800000000001em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord" style="padding-left:0.833em;"><span class="mord mathdefault">n</span></span></span><span style="top:-2.76028em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="min-width:0.853em;height:1.08em;"><svg width='400em' height='1.08em' viewBox='0 0 400000 1080' preserveAspectRatio='xMinYMin slice'><path d='M95,702c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,
-10,-9.5,-14c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54c44.2,-33.3,65.8,
-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10s173,378,173,378c0.7,0,
35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429c69,-144,104.5,-217.7,106.5,
-221c5.3,-9.3,12,-14,20,-14H400000v40H845.2724s-225.272,467,-225.272,467
s-235,486,-235,486c-2.7,4.7,-9,7,-19,7c-6,0,-10,-1,-12,-3s-194,-422,-194,-422
s-65,47,-65,47z M834 80H400000v40H845z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.23972em;"><span></span></span></span></span></span></span></span></span>的时候从数学上讲对随机数据是理论最快的。<br>
复杂度<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="script">O</mi><mo>(</mo><mi>q</mi><msqrt><mi>n</mi></msqrt><mo>)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O(q\sqrt{n})}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.05028em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8002800000000001em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord" style="padding-left:0.833em;"><span class="mord mathdefault">n</span></span></span><span style="top:-2.76028em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="min-width:0.853em;height:1.08em;"><svg width='400em' height='1.08em' viewBox='0 0 400000 1080' preserveAspectRatio='xMinYMin slice'><path d='M95,702c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,
-10,-9.5,-14c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54c44.2,-33.3,65.8,
-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10s173,378,173,378c0.7,0,
35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429c69,-144,104.5,-217.7,106.5,
-221c5.3,-9.3,12,-14,20,-14H400000v40H845.2724s-225.272,467,-225.272,467
s-235,486,-235,486c-2.7,4.7,-9,7,-19,7c-6,0,-10,-1,-12,-3s-194,-422,-194,-422
s-65,47,-65,47z M834 80H400000v40H845z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.23972em;"><span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span>。</p>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;

using namespace std;

typedef long long ll;

const int bis = 315, maxn = 123456;
int a[maxn];
ll kd[bis + 10][bis + 10];

int main() {
	int n, q, k, b;
	scanf(&quot;%d %d&quot;, &amp;n, &amp;q);
	for(int i = 1; i &lt;= n; ++i)
		scanf(&quot;%d&quot;, a + i);
	for(int i = 1; i &lt;= n; ++i) {
		for(int j = 1; j &lt;= bis; ++j) {
			kd[j][i % j] += a[i];
		}
	}
	while(q--) {
		scanf(&quot;%d %d&quot;, &amp;k, &amp;b);
		if(k &lt;= bis) {
			if(b &gt; k) printf(&quot;0\n&quot;);
			else printf(&quot;%lld\n&quot;, kd[k][b]);
		} else {
			ll ans = 0;
			for(int i = 0; ((ll)i * k + b) &lt;= n; ++i) {
				ans = ans + a[i * k + b];
			}
			printf(&quot;%lld\n&quot;, ans);
		}
	}
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[题解 [起跑线]提高模拟Round3]]></title>
        <id>https://froldh.github.io/post/qpx-tg-round3/</id>
        <link href="https://froldh.github.io/post/qpx-tg-round3/">
        </link>
        <updated>2020-02-26T14:45:05.000Z</updated>
        <summary type="html"><![CDATA[<p>Rnk3  T1、T2连续翻车丢人<br>
60 + 20 + 100</p>
]]></summary>
        <content type="html"><![CDATA[<p>Rnk3  T1、T2连续翻车丢人<br>
60 + 20 + 100</p>
<!-- more -->  
<h3 id="t1-简单问题">T1 简单问题</h3>
<p>给定 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo separator="true">,</mo><mi>k</mi></mrow><annotation encoding="application/x-tex">a,k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>，请你求出 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>a</mi><mn>1</mn></msup><mo>+</mo><msup><mi>a</mi><mn>2</mn></msup><mo>+</mo><msup><mi>a</mi><mn>3</mn></msup><mo>+</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo>+</mo><msup><mi>a</mi><mi>k</mi></msup></mrow><annotation encoding="application/x-tex">a^1+a^2+a^3+...+a^k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.849108em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span></span></span></span> 对 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>998244353</mn></mrow><annotation encoding="application/x-tex">998244353</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">9</span><span class="mord">9</span><span class="mord">8</span><span class="mord">2</span><span class="mord">4</span><span class="mord">4</span><span class="mord">3</span><span class="mord">5</span><span class="mord">3</span></span></span></span> 取模后的结果。<br>
由高中数学知识, 当<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mpadded width="0px"><mo></mo></mpadded><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">a \not = 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel"><span class="mord"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.69444em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="rlap"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="inner"><span class="mrel"></span></span><span class="fix"></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span></span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>时结果等于 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mover accent="true"><mfrac><mrow><msup><mi>a</mi><mi>k</mi></msup><mo>−</mo><mn>1</mn></mrow><mrow><mi>a</mi><mo>−</mo><mn>1</mn></mrow></mfrac><mo>˙</mo></mover></mrow><annotation encoding="application/x-tex">a \dot \frac{a^k-1}{a-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.581611em;vertical-align:-0.403331em;"></span><span class="mord mathdefault">a</span><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.17828em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9414199999999999em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">a</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight">a</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7820285714285713em;"><span style="top:-2.786em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.403331em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span><span style="top:-3.51042em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.13889em;">˙</span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.403331em;"><span></span></span></span></span></span></span></span></span>, <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">a = 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>时结果等于 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>.</p>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;

using namespace std;

typedef long long ll;

const ll mod = 998244353;

ll qp(ll a, ll b) {
   ll res = 1 % mod;
   for(; b; b &gt;&gt;= 1) {
   	if(b &amp; 1) res = res * a % mod;
   	a = a * a % mod;
   }
   return res;
}

int main() {
   ios::sync_with_stdio(false);
   cin.tie(0);
   ll a, k;
   cin &gt;&gt; a &gt;&gt; k;
   a %= mod;
   if(a == 1) cout &lt;&lt; (k % mod) &lt;&lt; '\n';
   else { 
   	ll res = a * (qp(a, k) - 1) % mod;
   	res = res * qp(a - 1, mod - 2) % mod;
   	cout &lt;&lt; res &lt;&lt; '\n';
   }
   return 0;
}
</code></pre>
<h3 id="t2-权值覆盖问题">T2 权值覆盖问题</h3>
<p>并查集写法挂掉了，题解给的是差分约束。<br>
等弄明白想法对不对再补上罢，咕咕咕。。。</p>
<h3 id="t3-删边问题">T3 删边问题</h3>
<p>套路化的离线解法，把删边看作是加边，然后对加边的情况进行讨论和更新(和BFS一致)即可。</p>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;

using namespace std;

const int inf = 0x3f3f3f3f;

struct edge {
	int u, v;
	edge() {}
	edge(int U, int V) : u(U), v(V) {}
};
vector&lt;edge&gt; edges;
vector&lt; vector&lt;int&gt; &gt; e, e_raw;
vector&lt;int&gt; del, ans, dis, dis_raw;
vector&lt;bool&gt; isdel;

queue&lt;int&gt; que;
void bfs_raw() {
	dis_raw[1] = 0;
	que.push(1);
	while(!que.empty()) {
		int cur = que.front(); que.pop();
		for(int ver : e_raw[cur]) {
			if(inf == dis_raw[ver]) {
				dis_raw[ver] = dis_raw[cur] + 1;
				que.push(ver); 
			}
		}
	}

}

void bfs_end() {
	dis[1] = 0;
	que.push(1);
	while(!que.empty()) {
		int cur = que.front(); que.pop();
		for(int ver : e[cur]) {
			if(inf == dis[ver]) {
				dis[ver] = dis[cur] + 1;
				que.push(ver);	
			}
		}
	}
}

int main() {
	ios::sync_with_stdio(false);
	cin.tie(0);
	int n, m, q, tmp, u, v;
	cin &gt;&gt; n &gt;&gt; m &gt;&gt; q;
	isdel.assign(m, false);
	edges.resize(m);
	e_raw.resize(n + 1);
	e.resize(n + 1);
	dis.assign(n + 1, inf);
	dis_raw.resize(n + 1, inf);
	ans.resize(q + 1);
	for(int i = 0; i &lt; m; ++i) {
		cin &gt;&gt; u &gt;&gt; v;
		edges[i] = edge(u, v);
		e_raw[u].push_back(v);
		e_raw[v].push_back(u);
	}
	for(int i = 0; i &lt; q; ++i) {
		cin &gt;&gt; tmp;
		--tmp;
		if(!isdel[tmp]) {
			isdel[tmp] = true;
			del.push_back(tmp);
		} else {
			del.push_back(-1);
		}
	}
	bfs_raw();
	for(int i = 0; i &lt; m; ++i)
		if(!isdel[i]) {
			e[edges[i].u].push_back(edges[i].v);
			e[edges[i].v].push_back(edges[i].u);
		}
	bfs_end();
	for(int i = 1; i &lt;= n; ++i)
		if(dis[i] != dis_raw[i])
			++ans[q];
	for(int i = q - 1; ~i; --i) {
		ans[i] = ans[i + 1];
		if(!~del[i]) continue;
		u = edges[del[i]].u, v = edges[del[i]].v;
		e[u].push_back(v);
		e[v].push_back(u);
		if(abs(dis[u] - dis[v]) &lt;= 1)
			continue;
		if(dis[u] &lt; dis[v]) swap(u, v);
		dis[u] = dis[v] + 1;
		if(dis[u] == dis_raw[u]) --ans[i];
		que.push(u);
		while(!que.empty()) {
			int cur = que.front(); que.pop();
			for(int ver : e[cur]) {
				if(dis[ver] &gt; dis[cur] + 1) {
					dis[ver] = dis[cur] + 1;
					if(dis[ver] == dis_raw[ver]) --ans[i];
					que.push(ver);
				}
			}
		}
	}
	for(int i = 1; i &lt;= q; ++i) cout &lt;&lt; ans[i] &lt;&lt; '\n';
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[题解 [起跑线]普及模拟Round4]]></title>
        <id>https://froldh.github.io/post/qpx-pj-round4/</id>
        <link href="https://froldh.github.io/post/qpx-pj-round4/">
        </link>
        <updated>2020-02-25T14:13:37.000Z</updated>
        <summary type="html"><![CDATA[<p>T2 fst Rnk8 丢人了</p>
]]></summary>
        <content type="html"><![CDATA[<p>T2 fst Rnk8 丢人了</p>
<!-- more -->  
<h3 id="t1-追击问题">T1 追击问题</h3>
<p>判断位移和相对速度方向是否一致即可。</p>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;

using namespace std;

typedef long long ll;

int main() {
	ios::sync_with_stdio(false);
	cin.tie(0);
	ll x, a, y, b;
	cin &gt;&gt; x &gt;&gt; a &gt;&gt; y &gt;&gt; b;
	if((x - y) * (a - b) &lt; 0) {
		cout &lt;&lt; &quot;YES&quot; &lt;&lt; '\n';	
	} else {
		cout &lt;&lt; &quot;NO&quot; &lt;&lt; '\n';
	}
	return 0;
}
</code></pre>
<h3 id="t2-最短路问题">T2 最短路问题</h3>
<p>如果没有额外的边，直接在图上跑BFS即可。<br>
对于特殊边，显然，如果一个集合的某点先被访问，那么其他点到另一个集合的边就没有更新距离的作用了。所以实际上有效的边只有<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="script">O</mi><mo>(</mo><mi>a</mi><mo>+</mo><mi>b</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O(a + b)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">b</span><span class="mclose">)</span></span></span></span></span>而不是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="script">O</mi><mo>(</mo><mi>a</mi><mi>b</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O(ab)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mord mathdefault">b</span><span class="mclose">)</span></span></span></span></span>。<br>
所以动态判断这些边的处理即可。<br>
复杂度<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="script">O</mi><mo>(</mo><mi>n</mi><mo>+</mo><mi>m</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O(n + m)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">m</span><span class="mclose">)</span></span></span></span></span></p>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;

using namespace std;

vector&lt; vector&lt;int&gt; &gt; edge;
vector&lt;int&gt; dis, c, d;
vector&lt;bool&gt; isC, isD;

queue&lt;int&gt; q;
void bfs() {
	bool visc = false, visd = false;
	q.push(1);
	dis[1] = 0;
	while(!q.empty()) {
		int cur = q.front(); q.pop();
		for(int ver : edge[cur])
			if(!~dis[ver]) {
				dis[ver] = dis[cur] + 1;
				q.push(ver);
			}
		if(isC[cur] &amp;&amp; !visd) {
			visd = true;
			for(int ver : d)
				if(!~dis[ver]) {
					dis[ver] = dis[cur] + 1;	
					q.push(ver);
				}
		}
		if(isD[cur] &amp;&amp; !visc) {
			visc = true;
			for(int ver : c)
				if(!~dis[ver]) {
					dis[ver] = dis[cur] + 1;
					q.push(ver);	
				}
		}
	}
}

int main() {
	ios::sync_with_stdio(false);
	cin.tie(0);
	int n, m, a, b, tmp, u, v;
	cin &gt;&gt; n &gt;&gt; m;
	edge.resize(n + 1);
	dis.assign(n + 1, -1);
	isC.assign(n, false);
	isD.assign(n, false);
	for(int i = 1; i &lt;= m; ++i) {
		cin &gt;&gt; u &gt;&gt; v;
		edge[u].push_back(v);
		edge[v].push_back(u);
	}
	cin &gt;&gt; a &gt;&gt; b;
	c.resize(a);
	d.resize(b);
	for(int i = 0; i &lt; a; ++i) {
		cin &gt;&gt; tmp;
		isC[tmp] = true;
		c[i] = tmp;
	}
	for(int i = 0; i &lt; b; ++i) {
		cin &gt;&gt; tmp;
		isD[tmp] = true;
		d[i] = tmp;
	}
	bfs();
	for(int i = 1; i &lt;= n; ++i)
		cout &lt;&lt; dis[i] &lt;&lt; '\n';
	return 0;
}
</code></pre>
<h3 id="t3-数码问题">T3 数码问题</h3>
<p>咕咕咕。。。</p>
<h3 id="t4-三角形问题">T4 三角形问题</h3>
<p>考虑构造最小的不能满足三角形的数列。<br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mo separator="true">,</mo><mn>1</mn><mo separator="true">,</mo><mn>2</mn><mo separator="true">,</mo><mn>3</mn><mo separator="true">,</mo><mn>5</mn><mo separator="true">,</mo><mn>8</mn><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">1, 1, 2, 3, 5, 8, ...</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">5</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">8</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span></span></span></span><br>
事斐波那契！<br>
第84项斐波那契<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>⩾</mo><mn>1</mn><msup><mn>0</mn><mn>18</mn></msup></mrow><annotation encoding="application/x-tex">\geqslant 10^{18}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7733399999999999em;vertical-align:-0.13667em;"></span><span class="mrel amsrm">⩾</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">8</span></span></span></span></span></span></span></span></span></span></span></span>, 根据抽屉原理, 树上路径长度<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>⩾</mo><mn>84</mn></mrow><annotation encoding="application/x-tex">\geqslant 84</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7733399999999999em;vertical-align:-0.13667em;"></span><span class="mrel amsrm">⩾</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">8</span><span class="mord">4</span></span></span></span>的一定能构成。<br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>⩽</mo><mn>84</mn></mrow><annotation encoding="application/x-tex">\leqslant 84</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7733399999999999em;vertical-align:-0.13667em;"></span><span class="mrel amsrm">⩽</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">8</span><span class="mord">4</span></span></span></span>的路径直接暴力求点权。<br>
复杂度<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="script">O</mi><mo>(</mo><mo>(</mo><mi>q</mi><mo>+</mo><mi>n</mi><mo>)</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O((q + n)logn)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></span></p>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;

using namespace std;

typedef long long ll;

const int maxn = 567890;
int t[maxn], k[maxn], b[maxn], head[maxn], ver[maxn&lt;&lt;1], nex[maxn&lt;&lt;1], tot;
inline void addedge(int u, int v) {
	ver[tot] = v; nex[tot] = head[u]; head[u] = tot++;	
}
int n, q;

int fa[maxn][32], dep[maxn];
void dfs(int cur, int pre) {
	dep[cur] = dep[pre] + 1; fa[cur][0] = pre;
	for(int i = 1; i &lt;= 30; ++i) fa[cur][i] = fa[fa[cur][i-1]][i-1];
	for(int i = head[cur]; ~i; i = nex[i])
		if(!dep[ver[i]]) dfs(ver[i], cur);
	
}

int lca(int u, int v) {
	if(dep[u] &lt; dep[v])	swap(u, v);
	for(int i = 30; ~i; --i) 
		if(dep[fa[u][i]] &gt;= dep[v])	u = fa[u][i];
	if(u == v) return u;
	for(int i = 30; ~i; --i)
		if(fa[u][i] != fa[v][i])
			u = fa[u][i], v = fa[v][i];
	return fa[u][0];
}

int main() {
	srand((unsigned)time(0));
	memset(head, -1, sizeof(head));
	ios::sync_with_stdio(false);
	cin.tie(0);
	int u, v;
	ll x;
	cin &gt;&gt; n;
	for(int i = 1; i &lt;= n; ++i)
		cin	&gt;&gt; t[i] &gt;&gt; k[i] &gt;&gt; b[i];
	for(int i = 1; i &lt; n; ++i) {
		cin &gt;&gt; u &gt;&gt; v;
		addedge(u, v);
		addedge(v, u);
	}
	dfs(1, 1);
	cin &gt;&gt; q;
	while(q--) {
		cin &gt;&gt; u &gt;&gt; v &gt;&gt; x;
		int lc = lca(u, v);
		if(-2 * dep[lc] + dep[v] + dep[u] + 1 &gt;= 84)
			cout &lt;&lt; &quot;YES&quot; &lt;&lt; '\n';
		else if(u == v) {
			cout &lt;&lt; &quot;NO&quot; &lt;&lt; '\n';
		} else {
			vector&lt;ll&gt; vec;
			while(u != lc) {
				vec.push_back(x * x * t[u] + x * k[u] + b[u]);
				u = fa[u][0];
			}
			while(v != lc) {
				vec.push_back(x * x * t[v] + x * k[v] + b[v]);
				v = fa[v][0];
			}
			vec.push_back(x * x * t[lc] + x * k[lc] + b[lc]);
			random_shuffle(vec.begin(), vec.end());
			bool flg = true;
			for(int i = 0; flg &amp;&amp; i &lt; vec.size(); ++i)
				for(int j = 0; flg &amp;&amp; j &lt; vec.size(); ++j)
					for(int k = 0; flg &amp;&amp; k &lt; vec.size(); ++k)
						if(i &lt; j &amp;&amp; j &lt; k) {
							ll sum = vec[i] + vec[j] + vec[k];
							ll mx = max(max(vec[i], vec[j]), vec[k]);
							if(sum - mx &gt; mx) {
								flg = false;
								break;	
							}
						}
			if(!flg) {
				cout &lt;&lt; &quot;YES&quot; &lt;&lt; '\n';	
			} else {
				cout &lt;&lt; &quot;NO&quot;&lt;&lt; '\n';	
			}
		}
	}
	return 0;
} 
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[题解 [起跑线]提高模拟Round2]]></title>
        <id>https://froldh.github.io/post/qpx-tg-round2/</id>
        <link href="https://froldh.github.io/post/qpx-tg-round2/">
        </link>
        <updated>2020-02-25T09:40:29.000Z</updated>
        <summary type="html"><![CDATA[<p>三题暴力拿Rnk5很丢人的好伐</p>
]]></summary>
        <content type="html"><![CDATA[<p>三题暴力拿Rnk5很丢人的好伐</p>
<!-- more -->
<h3 id="t1-数论">T1 数论</h3>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>⩽</mo><mn>20</mn></mrow><annotation encoding="application/x-tex">n \leqslant 20</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7733399999999999em;vertical-align:-0.13667em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel amsrm">⩽</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">0</span></span></span></span> ,  枚举所有倍数容斥原理做即可。 复杂度<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="script">O</mi><mo>(</mo><msup><mn mathvariant="script">2</mn><mi>n</mi></msup><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>r</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O(2^n nlogr)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathcal">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mclose">)</span></span></span></span></span></p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

using namespace std;

typedef long long ll;

vector&lt;ll&gt; v;
ll ans = 0, l, r;
int n;

void dfs(int cur, ll lcm, int sign) {
	if(cur == n) {
		ans += (r / lcm  - (l - 1) / lcm) * sign;
		return;
	}
	dfs(cur + 1, lcm, sign);
	ll g = __gcd(lcm, v[cur]);
	if((double)lcm / g * v[cur] &lt;= r)
		dfs(cur + 1, lcm / g * v[cur], -sign);
}

int main() {
	ios::sync_with_stdio(false);
	cin.tie(0);
	cin &gt;&gt; n &gt;&gt; l &gt;&gt; r;
	v.resize(n);
	for(int i = 0; i &lt; n; ++i)
		cin &gt;&gt; v[i];
	dfs(0, 1, 1);
	cout &lt;&lt; r - l + 1 - ans &lt;&lt; '\n'; 
	return 0;
}
</code></pre>
<h3 id="t2-术论">T2 术论</h3>
<p>正在咕。。。</p>
<h3 id="t3-数论">T3 数论</h3>
<p>正在咕。。。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[笔记 容斥原理]]></title>
        <id>https://froldh.github.io/post/rong-chi-yuan-li-bi-ji/</id>
        <link href="https://froldh.github.io/post/rong-chi-yuan-li-bi-ji/">
        </link>
        <updated>2020-02-25T06:05:40.000Z</updated>
        <summary type="html"><![CDATA[<p>关于容斥原理的学习笔记</p>
]]></summary>
        <content type="html"><![CDATA[<p>关于容斥原理的学习笔记</p>
<!-- more -->
<h3 id="原理">原理</h3>
<h4 id="公式摘自oi-wiki">公式(摘自OI-Wiki) :</h4>
<p>设 U 中元素有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 种不同的属性，而第 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 种属性称为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">P_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> ，拥有属性<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">P_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的元素构成集合 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>S</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">S_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> ，那么所有元素的并集大小为 :<br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle scriptlevel="0" displaystyle="true"><mrow><mo fence="true">∣</mo><munderover><mo>⋃</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><msub><mi>S</mi><mi>i</mi></msub><mo fence="true">∣</mo></mrow><mo>=</mo><munderover><mo>∑</mo><mrow><mi>m</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><mo>(</mo><mo>−</mo><mn>1</mn><msup><mo>)</mo><mrow><mi>m</mi><mo>−</mo><mn>1</mn></mrow></msup><munder><mo>∑</mo><mrow><msub><mi>a</mi><mi>i</mi></msub><mo>&lt;</mo><msub><mi>a</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow></munder><mrow><mo fence="true">∣</mo><munderover><mo>⋂</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>m</mi></munderover><msub><mi>S</mi><msub><mi>a</mi><mi>i</mi></msub></msub><mo fence="true">∣</mo></mrow></mstyle></mrow><annotation encoding="application/x-tex">\displaystyle \left| \bigcup_{i=1}^{n} S_i \right| = \sum_{m=1}^{n}(-1)^{m-1}\sum_{a_i &lt; a_{i + 1}} \left| \bigcap_{i=1}^{m} S_{a_i} \right|</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:3.057644em;vertical-align:-1.277669em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.7799749999999999em;"><span style="top:-1.355975em;"><span class="pstrut" style="height:2.606em;"></span><span class="delimsizinginner delim-size1"><span>∣</span></span></span><span style="top:-1.9619749999999998em;"><span class="pstrut" style="height:2.606em;"></span><span class="delimsizinginner delim-size1"><span>∣</span></span></span><span style="top:-2.5679749999999997em;"><span class="pstrut" style="height:2.606em;"></span><span class="delimsizinginner delim-size1"><span>∣</span></span></span><span style="top:-3.173975em;"><span class="pstrut" style="height:2.606em;"></span><span class="delimsizinginner delim-size1"><span>∣</span></span></span><span style="top:-3.779975em;"><span class="pstrut" style="height:2.606em;"></span><span class="delimsizinginner delim-size1"><span>∣</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.250025em;"><span></span></span></span></span></span></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6513970000000002em;"><span style="top:-1.872331em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.050005em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">⋃</span></span></span><span style="top:-4.3000050000000005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.277669em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.7799749999999999em;"><span style="top:-1.355975em;"><span class="pstrut" style="height:2.606em;"></span><span class="delimsizinginner delim-size1"><span>∣</span></span></span><span style="top:-1.9619749999999998em;"><span class="pstrut" style="height:2.606em;"></span><span class="delimsizinginner delim-size1"><span>∣</span></span></span><span style="top:-2.5679749999999997em;"><span class="pstrut" style="height:2.606em;"></span><span class="delimsizinginner delim-size1"><span>∣</span></span></span><span style="top:-3.173975em;"><span class="pstrut" style="height:2.606em;"></span><span class="delimsizinginner delim-size1"><span>∣</span></span></span><span style="top:-3.779975em;"><span class="pstrut" style="height:2.606em;"></span><span class="delimsizinginner delim-size1"><span>∣</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.250025em;"><span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:3.171745em;vertical-align:-1.3917700000000002em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6513970000000002em;"><span style="top:-1.882887em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">m</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.050005em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3000050000000005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.267113em;"><span></span></span></span></span></span><span class="mopen">(</span><span class="mord">−</span><span class="mord">1</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.864108em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">m</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.050005em;"><span style="top:-1.8999949999999997em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3280857142857143em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mrel mtight">&lt;</span><span class="mord mtight"><span class="mord mathdefault mtight">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32808571428571426em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.20252142857142857em;"><span></span></span></span></span></span></span></span></span></span><span style="top:-3.0500049999999996em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.3917700000000002em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.7799749999999999em;"><span style="top:-1.355975em;"><span class="pstrut" style="height:2.606em;"></span><span class="delimsizinginner delim-size1"><span>∣</span></span></span><span style="top:-1.9619749999999998em;"><span class="pstrut" style="height:2.606em;"></span><span class="delimsizinginner delim-size1"><span>∣</span></span></span><span style="top:-2.5679749999999997em;"><span class="pstrut" style="height:2.606em;"></span><span class="delimsizinginner delim-size1"><span>∣</span></span></span><span style="top:-3.173975em;"><span class="pstrut" style="height:2.606em;"></span><span class="delimsizinginner delim-size1"><span>∣</span></span></span><span style="top:-3.779975em;"><span class="pstrut" style="height:2.606em;"></span><span class="delimsizinginner delim-size1"><span>∣</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.250025em;"><span></span></span></span></span></span></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6513970000000002em;"><span style="top:-1.872331em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.050005em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">⋂</span></span></span><span style="top:-4.3000050000000005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">m</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.277669em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139199999999997em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3280857142857143em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2501em;"><span></span></span></span></span></span></span><span class="mclose"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.7799749999999999em;"><span style="top:-1.355975em;"><span class="pstrut" style="height:2.606em;"></span><span class="delimsizinginner delim-size1"><span>∣</span></span></span><span style="top:-1.9619749999999998em;"><span class="pstrut" style="height:2.606em;"></span><span class="delimsizinginner delim-size1"><span>∣</span></span></span><span style="top:-2.5679749999999997em;"><span class="pstrut" style="height:2.606em;"></span><span class="delimsizinginner delim-size1"><span>∣</span></span></span><span style="top:-3.173975em;"><span class="pstrut" style="height:2.606em;"></span><span class="delimsizinginner delim-size1"><span>∣</span></span></span><span style="top:-3.779975em;"><span class="pstrut" style="height:2.606em;"></span><span class="delimsizinginner delim-size1"><span>∣</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.250025em;"><span></span></span></span></span></span></span></span></span></span></span><br>
若求交集，则利用全集减去补集的并集 :<br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle scriptlevel="0" displaystyle="true"><mrow><mo fence="true">∣</mo><munderover><mo>⋂</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><msub><mi>S</mi><mi>i</mi></msub><mo fence="true">∣</mo></mrow><mo>=</mo><mrow><mo fence="true">∣</mo><mi>U</mi><mo fence="true">∣</mo></mrow><mo>−</mo><mrow><mo fence="true">∣</mo><munderover><mo>⋃</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><msubsup><mi mathvariant="normal">∁</mi><mi>U</mi><msub><mi>S</mi><mi>i</mi></msub></msubsup><mo fence="true">∣</mo></mrow></mstyle></mrow><annotation encoding="application/x-tex">\displaystyle \left| \bigcap_{i=1}^{n} S_i \right| = \left| U \right| - \left| \bigcup_{i=1}^{n} \complement_U^{S_i} \right|</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:3.057644em;vertical-align:-1.277669em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.7799749999999999em;"><span style="top:-1.355975em;"><span class="pstrut" style="height:2.606em;"></span><span class="delimsizinginner delim-size1"><span>∣</span></span></span><span style="top:-1.9619749999999998em;"><span class="pstrut" style="height:2.606em;"></span><span class="delimsizinginner delim-size1"><span>∣</span></span></span><span style="top:-2.5679749999999997em;"><span class="pstrut" style="height:2.606em;"></span><span class="delimsizinginner delim-size1"><span>∣</span></span></span><span style="top:-3.173975em;"><span class="pstrut" style="height:2.606em;"></span><span class="delimsizinginner delim-size1"><span>∣</span></span></span><span style="top:-3.779975em;"><span class="pstrut" style="height:2.606em;"></span><span class="delimsizinginner delim-size1"><span>∣</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.250025em;"><span></span></span></span></span></span></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6513970000000002em;"><span style="top:-1.872331em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.050005em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">⋂</span></span></span><span style="top:-4.3000050000000005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.277669em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.7799749999999999em;"><span style="top:-1.355975em;"><span class="pstrut" style="height:2.606em;"></span><span class="delimsizinginner delim-size1"><span>∣</span></span></span><span style="top:-1.9619749999999998em;"><span class="pstrut" style="height:2.606em;"></span><span class="delimsizinginner delim-size1"><span>∣</span></span></span><span style="top:-2.5679749999999997em;"><span class="pstrut" style="height:2.606em;"></span><span class="delimsizinginner delim-size1"><span>∣</span></span></span><span style="top:-3.173975em;"><span class="pstrut" style="height:2.606em;"></span><span class="delimsizinginner delim-size1"><span>∣</span></span></span><span style="top:-3.779975em;"><span class="pstrut" style="height:2.606em;"></span><span class="delimsizinginner delim-size1"><span>∣</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.250025em;"><span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">∣</span><span class="mord mathdefault" style="margin-right:0.10903em;">U</span><span class="mclose delimcenter" style="top:0em;">∣</span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:3.057644em;vertical-align:-1.277669em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.7799749999999999em;"><span style="top:-1.355975em;"><span class="pstrut" style="height:2.606em;"></span><span class="delimsizinginner delim-size1"><span>∣</span></span></span><span style="top:-1.9619749999999998em;"><span class="pstrut" style="height:2.606em;"></span><span class="delimsizinginner delim-size1"><span>∣</span></span></span><span style="top:-2.5679749999999997em;"><span class="pstrut" style="height:2.606em;"></span><span class="delimsizinginner delim-size1"><span>∣</span></span></span><span style="top:-3.173975em;"><span class="pstrut" style="height:2.606em;"></span><span class="delimsizinginner delim-size1"><span>∣</span></span></span><span style="top:-3.779975em;"><span class="pstrut" style="height:2.606em;"></span><span class="delimsizinginner delim-size1"><span>∣</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.250025em;"><span></span></span></span></span></span></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6513970000000002em;"><span style="top:-1.872331em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.050005em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">⋃</span></span></span><span style="top:-4.3000050000000005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.277669em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord amsrm">∁</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9232309999999999em;"><span style="top:-2.4064690000000004em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.10903em;">U</span></span></span><span style="top:-3.1449em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3280857142857143em;"><span style="top:-2.357em;margin-left:-0.05764em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.29353099999999993em;"><span></span></span></span></span></span></span><span class="mclose"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.7799749999999999em;"><span style="top:-1.355975em;"><span class="pstrut" style="height:2.606em;"></span><span class="delimsizinginner delim-size1"><span>∣</span></span></span><span style="top:-1.9619749999999998em;"><span class="pstrut" style="height:2.606em;"></span><span class="delimsizinginner delim-size1"><span>∣</span></span></span><span style="top:-2.5679749999999997em;"><span class="pstrut" style="height:2.606em;"></span><span class="delimsizinginner delim-size1"><span>∣</span></span></span><span style="top:-3.173975em;"><span class="pstrut" style="height:2.606em;"></span><span class="delimsizinginner delim-size1"><span>∣</span></span></span><span style="top:-3.779975em;"><span class="pstrut" style="height:2.606em;"></span><span class="delimsizinginner delim-size1"><span>∣</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.250025em;"><span></span></span></span></span></span></span></span></span></span></span></p>
<h4 id="感性理解">感性理解 :</h4>
<p>求并集，需要不断地把重复统计的元素减去。<br>
全集减去补集的并的部分即为所有补集都没有的部分，换言之，时所有原集合共有的部分，即交集。</p>
<h3 id="一般实现方法">一般实现方法 :</h3>
<p>通过枚举所有的选取方案求容斥，一种是利用二进制表示选取的方式，一种是用dfs。</p>
<h4 id="1-dfs法">1) dfs法</h4>
<pre><code class="language-cpp">//借鉴jiangly神仙的代码改编
Number ans;
void dfs(int cur, int sign, Number valueState) {
	if(cur == n) {
		ans += valueState;
		return;
	}
	dfs(cur + 1, sign, valueState);    //不选
	dfs(cur + 1，-sign, valueState + calc(cur)); //选择
}

signed main() {
    ...
    dfs(0, 1, ...);
    ...
}
</code></pre>
<h4 id="2-二进制枚举">2) 二进制枚举</h4>
<p>正在咕。。。</p>
<h4 id="3-数组模拟二进制">3) 数组模拟二进制</h4>
<p>正在咕。。。</p>
<h3 id="应用">应用</h3>
<p>正在咕。。。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[题解 luoguP2002 消息扩散]]></title>
        <id>https://froldh.github.io/post/ti-jie-luogup2002-xiao-xi-kuo-san/</id>
        <link href="https://froldh.github.io/post/ti-jie-luogup2002-xiao-xi-kuo-san/">
        </link>
        <updated>2020-01-11T15:29:26.000Z</updated>
        <summary type="html"><![CDATA[<p>跑个tarjan缩点。然后同一个scc的点可以互传。</p>
]]></summary>
        <content type="html"><![CDATA[<p>跑个tarjan缩点。然后同一个scc的点可以互传。</p>
<!--more-->  
<p>缩点后是一个DAG,然后只要向入度为0的点传信息即可。</p>
<p>细节:</p>
<ol>
<li>在实现时统计入度,要判断边的起点和终点是否在同一个scc中,是的话不要加入度</li>
<li>很多题解都说要特判自环,实际上不需要的,强连通分量的含义是极大的强连通子图。</li>
</ol>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;cstring&gt;

using namespace std;

const int N = 123456, M = 567890;
int head[N], ver[M], nex[M], my[M], tot;
inline void addedge(int u, int v) {
    ver[tot] = v; my[tot] = u; nex[tot] = head[u]; head[u] = tot++;
}

int co[N], dfn[N], low[N], sta[N], ind[N], top, dfs_clock = 1, col = 1;
void tarjan(int cur) {
    dfn[cur] = low[cur] = dfs_clock++;
    sta[top++] = cur;
    for(int i = head[cur]; ~i; i = nex[i]) {
        if(!dfn[ver[i]]) {
            tarjan(ver[i]);
            low[cur] = min(low[cur], low[ver[i]]);
        } else if(!co[ver[i]]) {
            low[cur] = min(low[cur], dfn[ver[i]]);
        }
    }
    if(dfn[cur] == low[cur]) {
        while(sta[--top] != cur) {
            co[sta[top]] = col;
        }
        co[cur] = col++;
    }
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    memset(head, -1, sizeof(head));
    memset(ind, 0, sizeof(ind));
    int n, m, u, v, cnt = 0;
    cin &gt;&gt; n &gt;&gt; m;
    for(int i = 1; i &lt;= m; ++i) {
        cin &gt;&gt; u &gt;&gt; v;
        if(u != v) addedge(u, v);
    }
    for(int i = 1; i &lt;= n; ++i) if(!co[i]) tarjan(i);
    for(int i = 0; i &lt; tot; ++i) if(co[my[i]] != co[ver[i]]) ind[co[ver[i]]] = 1;
    for(int i = 1; i &lt; col; ++i)
        if(!ind[i]) ++cnt;
    cout &lt;&lt; cnt &lt;&lt; '\n';
    return 0;
}

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[题解 [XJOI] CSP-S2开放一]]></title>
        <id>https://froldh.github.io/post/ti-jie-xjoi-csp-s2-kai-fang-yi/</id>
        <link href="https://froldh.github.io/post/ti-jie-xjoi-csp-s2-kai-fang-yi/">
        </link>
        <updated>2019-11-11T08:11:53.000Z</updated>
        <summary type="html"><![CDATA[<p>期望得分 100+100+60 = 260<br>
实际得分 30+20+70 = 120</p>
]]></summary>
        <content type="html"><![CDATA[<p>期望得分 100+100+60 = 260<br>
实际得分 30+20+70 = 120</p>
<!--more-->  
<h3 id="t1">T1</h3>
<p>实际上是个暴力枚举<br>
考场打炸了,RE30<br>
订正代码</p>
<pre><code class="language-cpp">#include &lt;cstdio&gt;
#define ll long long
 
using namespace std;
 
const int p[] = {1, 10, 100, 1000, 10000, 100000, 1000000, 10000000, 100000000};
 
int main() {
    int t;
    scanf(&quot;%d&quot;, &amp;t);
    while(t--) {
        ll cnt = 0;
        int l, r, tmp, n;
        scanf(&quot;%d %d&quot;, &amp;l, &amp;r);
        tmp = l; n = 0;
        while(tmp) {   
            tmp /= 10; ++n;
        }
        for(int i = l; i &lt;= r; ++i) {
            tmp = i;
            int low = tmp % 10; tmp /= 10; tmp += low * p[n-1];
            while(tmp != i) {
                if(low &amp;&amp; tmp &gt;= l &amp;&amp; tmp &lt;= r) ++cnt;
                low = tmp % 10; tmp /= 10; tmp += low * p[n-1];
            }
        }
        printf(&quot;%lld\n&quot;, cnt / 2);
    }
    return 0;
}
</code></pre>
<h3 id="t2">T2</h3>
<p>实际上就是最短路计数<br>
考虑把下半边折上去,就满足对称性<br>
然后跑最短路计数<br>
这里建了虚拟节点0方便统计<br>
考场上表头开小导致死循环了得分20,开大就对了<br>
RE代码</p>
<pre><code class="language-cpp">#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;queue&gt;

using namespace std;

const int N = 123, MOD = 1000000009, INF = 0x3f3f3f3f;
int a[N][N];
int head[N], ver[N*N], wei[N*N], nex[N*N], tot;
inline void addedge(int u, int v, int w) {
	ver[tot] = v, wei[tot] = w, nex[tot] = head[u], head[u] = tot++;
}

struct node{
	int x, d;
	node() {}
	node(int X, int DIS) : x(X), d(DIS) {}
	bool operator &lt; (const node&amp; o) const { return d &lt; o.d; }
};
priority_queue&lt;node&gt; q;
int dis[N*N], f[N*N];
void dij() {
	memset(dis, INF, sizeof(dis));
	memset(f, 0, sizeof(f));
	dis[1] = a[1][1]; f[1] = 1;
	q.push(node(1, dis[1]));
	while(!q.empty()) {
		node cur = q.top(); q.pop();
		if(-cur.d &gt; dis[cur.x]) continue;
		for(int i = head[cur.x]; ~i; i = nex[i])
			if(dis[ver[i]] &gt; dis[cur.x] + wei[i]) {
				dis[ver[i]] = dis[cur.x] + wei[i];
				f[ver[i]] = f[cur.x];
				q.push(node(ver[i], -dis[ver[i]]));
			} else if(dis[ver[i]] == dis[cur.x] + wei[i]) {
				f[ver[i]] = (f[cur.x] + f[ver[i]]) % MOD;
			}
				
	}
}

int main() {
	int n;
	while(~scanf(&quot;%d&quot;, &amp;n) &amp;&amp; n) {
		for(int i = 1; i &lt;= n; ++i)
			for(int j = 1; j &lt;= n; ++j) {
				scanf(&quot;%d&quot;, &amp;a[i][j]);
				if(j &gt; n+1-i) a[n+1-j][n+1-i] += a[i][j];
			}
		memset(head, -1, sizeof(head));
		tot = 0;
		for(int i = 1; i &lt;= n; ++i)
			for(int j = 1; j &lt;= n+1-i; ++j) {
					int cur = (i-1)*n+j;
					if(j != 1) addedge(cur, cur-1, a[i][j-1]);
					if(j != n+1-i) addedge(cur, cur+1, a[i][j+1]), addedge(cur, cur+n, a[i+1][j]);
					if(i != 1) addedge(cur, cur-n, a[i-1][j]);
					if(i+j == n+1) addedge((i-1)*n+j, 0, 0);
				}
		dij();
		printf(&quot;%d\n&quot;, f[0]);
	}
	return 0;
}
</code></pre>
<p>订正代码:</p>
<pre><code class="language-cpp">#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;queue&gt;

using namespace std;

const int N = 123, MOD = 1000000009, INF = 0x3f3f3f3f;
int a[N][N];
int head[N*N], ver[N*N*N], wei[N*N*N], nex[N*N*N], tot;
inline void addedge(int u, int v, int w) {
	ver[tot] = v, wei[tot] = w, nex[tot] = head[u], head[u] = tot++;
}

struct node{
	int x, d;
	node() {}
	node(int X, int DIS) : x(X), d(DIS) {}
	bool operator &lt; (const node&amp; o) const { return d &lt; o.d; }
};
priority_queue&lt;node&gt; q;
int dis[N*N], f[N*N];
void dij() {
	memset(dis, INF, sizeof(dis));
	memset(f, 0, sizeof(f));
	dis[1] = a[1][1]; f[1] = 1;
	q.push(node(1, dis[1]));
	while(!q.empty()) {
		node cur = q.top(); q.pop();
		if(-cur.d &gt; dis[cur.x]) continue;
		for(int i = head[cur.x]; ~i; i = nex[i])
			if(dis[ver[i]] &gt; dis[cur.x] + wei[i]) {
				dis[ver[i]] = dis[cur.x] + wei[i];
				f[ver[i]] = f[cur.x];
				q.push(node(ver[i], -dis[ver[i]]));
			} else if(dis[ver[i]] == dis[cur.x] + wei[i]) {
				f[ver[i]] = (f[cur.x] + f[ver[i]]) % MOD;
			}
				
	}
}

int main() {
	int n;
	while(~scanf(&quot;%d&quot;, &amp;n) &amp;&amp; n) {
		for(int i = 1; i &lt;= n; ++i)
			for(int j = 1; j &lt;= n; ++j) {
				scanf(&quot;%d&quot;, &amp;a[i][j]);
				if(j &gt; n+1-i) a[n+1-j][n+1-i] += a[i][j];
			}
		memset(head, -1, sizeof(head));
		tot = 0;
		for(int i = 1; i &lt;= n; ++i)
			for(int j = 1; j &lt;= n+1-i; ++j) {
					int cur = (i-1)*n+j;
					if(j != 1) addedge(cur, cur-1, a[i][j-1]);
					if(j != n+1-i) addedge(cur, cur+1, a[i][j+1]), addedge(cur, cur+n, a[i+1][j]);
					if(i != 1) addedge(cur, cur-n, a[i-1][j]);
					if(i+j == n+1) addedge((i-1)*n+j, 0, 0);
				}
		dij();
		printf(&quot;%d\n&quot;, f[0]);
	}
	return 0;
}
</code></pre>
<h3 id="t3">T3</h3>
<p>考场上打了个树上背包暴力<br>
70</p>
<p>70分代码,树上背包</p>
<pre><code class="language-cpp">#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;

using namespace std;

const int N = 3456;
int head[N], ver[N&lt;&lt;1], nex[N&lt;&lt;1], tot, n;
inline void addedge(int u, int v) {
	ver[tot] = v; nex[tot] = head[u]; head[u] = tot++;
}
int a[N], f[N][N], lim;
void dfs(int cur, int pre) {
	for(int i = head[cur]; ~i; i = nex[i])
		if(pre != ver[i]) {
			dfs(ver[i], cur);
			for(int j = lim; ~j; --j)
				for(int k = j; ~k; --k)
					f[cur][j] = max(f[cur][j], f[cur][j-k] + f[ver[i]][k]);
		}
	for(int i = lim; i &gt; 0; --i)
		f[cur][i] = f[cur][i-1] + a[cur];
}

int main() {
	memset(head, -1, sizeof(head));
	int u, v;
	scanf(&quot;%d %d&quot;, &amp;n, &amp;lim);
	for(int i = 1; i &lt;= n; ++i) scanf(&quot;%d&quot;, a + i);
	for(int i = 1; i &lt; n; ++i) {
		scanf(&quot;%d %d&quot;, &amp;u, &amp;v);
		addedge(u, v);
		addedge(v, u);
	}
	dfs(1, 0);
	printf(&quot;%d\n&quot;, f[1][lim]);
	return 0;
}
</code></pre>
<p>100分代码<br>
鬼知道是这种优化！！！<br>
背包范围按<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi><mi>i</mi><mi>n</mi><mo>(</mo><mi>s</mi><mi>i</mi><mi>z</mi><mi>e</mi><mo separator="true">,</mo><mi>l</mi><mi>i</mi><mi>m</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">min(size, lim)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mopen">(</span><span class="mord mathdefault">s</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="mord mathdefault">e</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">i</span><span class="mord mathdefault">m</span><span class="mclose">)</span></span></span></span>枚举</p>
<pre><code class="language-cpp">#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;queue&gt;

using namespace std;

const int N = 123, MOD = 1000000009, INF = 0x3f3f3f3f;
int a[N][N];
int head[N*N], ver[N*N*N], wei[N*N*N], nex[N*N*N], tot;
inline void addedge(int u, int v, int w) {
	ver[tot] = v, wei[tot] = w, nex[tot] = head[u], head[u] = tot++;
}

struct node{
	int x, d;
	node() {}
	node(int X, int DIS) : x(X), d(DIS) {}
	bool operator &lt; (const node&amp; o) const { return d &lt; o.d; }
};
priority_queue&lt;node&gt; q;
int dis[N*N], f[N*N];
void dij() {
	memset(dis, INF, sizeof(dis));
	memset(f, 0, sizeof(f));
	dis[1] = a[1][1]; f[1] = 1;
	q.push(node(1, dis[1]));
	while(!q.empty()) {
		node cur = q.top(); q.pop();
		if(-cur.d &gt; dis[cur.x]) continue;
		for(int i = head[cur.x]; ~i; i = nex[i])
			if(dis[ver[i]] &gt; dis[cur.x] + wei[i]) {
				dis[ver[i]] = dis[cur.x] + wei[i];
				f[ver[i]] = f[cur.x];
				q.push(node(ver[i], -dis[ver[i]]));
			} else if(dis[ver[i]] == dis[cur.x] + wei[i]) {
				f[ver[i]] = (f[cur.x] + f[ver[i]]) % MOD;
			}
				
	}
}

int main() {
	int n;
	while(~scanf(&quot;%d&quot;, &amp;n) &amp;&amp; n) {
		for(int i = 1; i &lt;= n; ++i)
			for(int j = 1; j &lt;= n; ++j) {
				scanf(&quot;%d&quot;, &amp;a[i][j]);
				if(j &gt; n+1-i) a[n+1-j][n+1-i] += a[i][j];
			}
		memset(head, -1, sizeof(head));
		tot = 0;
		for(int i = 1; i &lt;= n; ++i)
			for(int j = 1; j &lt;= n+1-i; ++j) {
					int cur = (i-1)*n+j;
					if(j != 1) addedge(cur, cur-1, a[i][j-1]);
					if(j != n+1-i) addedge(cur, cur+1, a[i][j+1]), addedge(cur, cur+n, a[i+1][j]);
					if(i != 1) addedge(cur, cur-n, a[i-1][j]);
					if(i+j == n+1) addedge((i-1)*n+j, 0, 0);
				}
		dij();
		printf(&quot;%d\n&quot;, f[0]);
	}
	return 0;
}
</code></pre>
<p>问题：细节方面很不小心,T2存图的表头开小直接TLE丢掉80分<br>
T3认为复杂度不对就没打优化,还是要敢试<br>
T1RE可能也不是特别出乎意料吧,毕竟拍都懒得拍了<br>
就这样漏洞百出我竟然还敢提前48分钟交卷<br>
总的来说应当更加仔细<br>
应该拍大数据(雾)<br>
考场上最后的时间要留出来检查表头有没有开够,以及一些初始化的细节<br>
还是考挂了自己菜,要多加油了</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[题解 luoguP1379 八数码难题]]></title>
        <id>https://froldh.github.io/post/ti-jie-luogup1379-ba-shu-ma-nan-ti/</id>
        <link href="https://froldh.github.io/post/ti-jie-luogup1379-ba-shu-ma-nan-ti/">
        </link>
        <updated>2019-11-11T00:43:05.000Z</updated>
        <summary type="html"><![CDATA[<p>看到很多神仙都是一顿A* / 双向广搜 等操作。<br>
其实状态数也没那么多</p>
]]></summary>
        <content type="html"><![CDATA[<p>看到很多神仙都是一顿A* / 双向广搜 等操作。<br>
其实状态数也没那么多</p>
<!--more-->  
<p>直接hash存储已经搜过的值,然后暴力地广搜就能过<br>
用string来表示状态,map存一下就好了</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;map&gt;
#include &lt;queue&gt;
#define pis pair&lt;int,string&gt;

using namespace std;

const string end = &quot;123804765&quot;;

inline int findZero(string s) { for(int i = 0; i &lt; 9; ++i) if(s[i] == '0') return i; }
map&lt;string, bool&gt; hash;
queue&lt;pis&gt; q;
int bfs(string start) {
	hash[start] = true;
	q.push(make_pair(0, start));
	while(!q.empty()) {
		int d = q.front().first;
		string cur = q.front().second;
		q.pop();
		if(cur == end) {
			return d;
		}
		int x = findZero(cur);
		string tmp;
		if(x / 3 != 0) {
			tmp = cur;
			swap(tmp[x], tmp[x-3]);
			if(!hash[tmp]) {
				hash[tmp] = true;
				q.push(make_pair(d + 1, tmp));
			}
		}
		if(x % 3 != 0) {
			tmp = cur;
			swap(tmp[x], tmp[x - 1]);
			if(!hash[tmp]) {
				hash[tmp] = true;
				q.push(make_pair(d + 1, tmp));
			}
		}
		if(x % 3 != 2) {
			tmp = cur;
			swap(tmp[x], tmp[x + 1]);
			if(!hash[tmp]) {
				hash[tmp] = true;
				q.push(make_pair(d + 1, tmp));
			}
		}
		if(x / 3 != 2) {
			tmp = cur;
			swap(tmp[x], tmp[x + 3]);
			if(!hash[tmp]) {
				hash[tmp] = true;
				q.push(make_pair(d + 1, tmp));
			}
		}
	}
	return -1;
}

int main() {
	ios::sync_with_stdio(false);
	string start;
	cin &gt;&gt; start;
	cout &lt;&lt; bfs(start) &lt;&lt; endl;
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[题解 luoguP3387 [模板]缩点]]></title>
        <id>https://froldh.github.io/post/title-ti-jie-luogup3387-mo-ban-suo-dian/</id>
        <link href="https://froldh.github.io/post/title-ti-jie-luogup3387-mo-ban-suo-dian/">
        </link>
        <updated>2019-11-10T13:05:33.000Z</updated>
        <summary type="html"><![CDATA[<p>tarjan缩点后形成一个DAG</p>
]]></summary>
        <content type="html"><![CDATA[<p>tarjan缩点后形成一个DAG</p>
<!--more-->
<p>然后根据tarjan的性质,缩点的编号为逆拓扑序<br>
直接按缩点编号降序DP即可</p>
<pre><code class="language-cpp">#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;

using namespace std;

const int N = 12345, M = 123456;
int head[N&lt;&lt;1], ver[M&lt;&lt;1], my[M&lt;&lt;1], nex[M&lt;&lt;1], tot;
inline void addedge(int u, int v) {
	ver[tot] = v, nex[tot] = head[u], my[tot] = u, head[u] = tot++;
}

int dfn[N], low[N], a[N], sta[N], co[N], sum[N], top, dfs_clock = 1, col = 1;
void tarjan(int cur) {
	dfn[cur] = low[cur] = dfs_clock++;
	sta[top++] = cur;
	for(int i = head[cur]; ~i; i = nex[i])
		if(!dfn[ver[i]]) {
			tarjan(ver[i]);
			low[cur] = min(low[cur], low[ver[i]]);
		} else if(!co[ver[i]]) {
			low[cur] = min(low[cur], dfn[ver[i]]);
		}
	if(dfn[cur] == low[cur]) {
		while(sta[--top] != cur) {
			co[sta[top]] = col;
			sum[col] += a[sta[top]];
		}
		sum[col] += a[cur];
		co[cur] = col++;
	}
} 

int f[N];

int main() {
	memset(head, -1, sizeof(head));
	int n, m, u, v, ans = 0;
	scanf(&quot;%d %d&quot;, &amp;n, &amp;m);
	for(int i = 1; i &lt;= n; ++i) scanf(&quot;%d&quot;, a + i);
	for(int i = 1; i &lt;= m; ++i) {
		scanf(&quot;%d %d&quot;, &amp;u, &amp;v);
		addedge(u, v);
	}
	for(int i = 1; i &lt;= n; ++i) if(!dfn[i]) tarjan(i);
	for(int i = 0, end = tot; i &lt; end; ++i)
		if(co[my[i]] != co[ver[i]])
			addedge(co[my[i]] + n, co[ver[i]]);
	for(int i = col - 1; i; --i) {
		f[i] += sum[i];
		ans = max(f[i], ans);
		for(int j = head[i+n]; ~j; j = nex[j])
			f[ver[j]] = max(f[i], f[ver[j]]);
	}
	printf(&quot;%d\n&quot;, ans);
	return 0;
}
</code></pre>
]]></content>
    </entry>
</feed>