<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://froldh.github.io</id>
    <title>oldherd&apos;s blog</title>
    <updated>2020-02-28T02:59:23.726Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://froldh.github.io"/>
    <link rel="self" href="https://froldh.github.io/atom.xml"/>
    <subtitle>又弱又笨的蒟蒻的博客</subtitle>
    <logo>https://froldh.github.io/images/avatar.png</logo>
    <icon>https://froldh.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, oldherd&apos;s blog</rights>
    <entry>
        <title type="html"><![CDATA[题解 [起跑线]普及模拟Round5]]></title>
        <id>https://froldh.github.io/post/qpx-pj-round5/</id>
        <link href="https://froldh.github.io/post/qpx-pj-round5/">
        </link>
        <updated>2020-02-27T14:29:44.000Z</updated>
        <summary type="html"><![CDATA[<p>这场人均AK罢，T2挂了(鬼晓得有负数哦，时间够还去剪枝就是作死)<br>
Rnk12 300丢死人了</p>
]]></summary>
        <content type="html"><![CDATA[<p>这场人均AK罢，T2挂了(鬼晓得有负数哦，时间够还去剪枝就是作死)<br>
Rnk12 300丢死人了</p>
<!-- more -->
<h3 id="t1-解方程">T1 解方程</h3>
<p>取几个模数暴力就好了。听说自然溢出也能过？<br>
复杂度<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="script">O</mi><mo>(</mo><mi>n</mi><mi>r</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O(nr)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mclose">)</span></span></span></span></span></p>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;

using namespace std;

typedef long long ll;

const ll m1 = 998244353, m2 = 19260817, m3 = 1000000007;
vector&lt;ll&gt; a, ans;


int main() {
	ios::sync_with_stdio(false);
	cin.tie(0);
	int n, l, r, cnt = 0;
	cin &gt;&gt; n &gt;&gt; l &gt;&gt; r;
	a.resize(n + 1);
	for(int i = 0; i &lt;= n; ++i) cin &gt;&gt; a[i];
	for(int i = l; i &lt;= r; ++i) {
		ll t1 = 1, t2 = 1, t3 = 1, a1 = 0, a2 = 0, a3 = 0;
		for(int j = 0; j &lt;= n; ++j) {
			a1 = (a1 + (t1 * a[j]) % m1) % m1;
			a2 = (a2 + (t2 * a[j]) % m2) % m2;
			a3 = (a3 + (t3 * a[j]) % m3) % m3;
			t1 = t1 * i % m1;
			t2 = t2 * i % m2;
			t3 = t3 * i % m3;
		}
		if(a1 == 0 &amp;&amp; a2 == 0 &amp;&amp; a3 == 0) {
			ans.push_back(i);
			++cnt;
		}
	}
	cout &lt;&lt; cnt &lt;&lt; '\n';
	for(int i = 0; i &lt; cnt; ++i) cout &lt;&lt; ans[i] &lt;&lt; '\n';
	return 0;
}
</code></pre>
<h3 id="t2-求和问题">T2 求和问题</h3>
<p>暴力dfs。<br>
艹，竟然有负数，不要去用可行性剪枝。<br>
复杂度<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="script">O</mi><mo>(</mo><msup><mn mathvariant="script">2</mn><mi>n</mi></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O(2^n)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathcal">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span></p>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;

using namespace std;

typedef long long ll;

vector&lt;ll&gt; x;
ll ans;
int n, k, q;

void dfs(int cur, ll sum, int cnt) {
	if(cur == n) {
		if(sum == q &amp;&amp; k == cnt) ++ans;
		return;	
	}
	dfs(cur + 1, sum, cnt);
	if(cnt &lt; k)
		dfs(cur + 1, sum + x[cur], cnt + 1);
}

bool cmp(ll a, ll b) {
	return a &gt; b;	
}

int main() {
	ios::sync_with_stdio(false);
	cin.tie(0);
	cin &gt;&gt; n &gt;&gt; k &gt;&gt; q;
	x.resize(n);
	for(int i = 0; i &lt; n; ++i) {
		cin &gt;&gt; x[i];
	}
	sort(x.begin(), x.end(), cmp); 
	dfs(0, 0, 0);
	cout &lt;&lt; ans &lt;&lt; '\n';
	return 0;
}
</code></pre>
<h3 id="t3-集合">T3 集合</h3>
<p>先排序，枚举最小值，二分查最大值，中间的数都能选。<br>
复杂度<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="script">O</mi><mo>(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo>+</mo><mi>q</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O(nlogn + qlognlogn)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></span>(预处理2的幂表格应该是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="script">O</mi><mo>(</mo><mo>(</mo><mi>n</mi><mo>+</mo><mi>q</mi><mo>)</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O((n+q)logn)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="mclose">)</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></span>)</p>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;

using namespace std;

typedef long long ll;

const ll mod = 1000000007;

vector&lt;ll&gt; v;

int bsh(int l, int r, ll x) {
	while(l &lt; r) {
		int mid = (l + r + 1) &gt;&gt; 1;
		if(v[mid] &lt;= x) l = mid;
		else r = mid - 1;
	}
	return l;
}

ll qp(ll a, ll b) {
	ll res = 1 % mod;
	for(; b; b &gt;&gt;= 1) {
		if(b &amp; 1) res = res * a % mod;
		a = a * a % mod;
	}
	return res;
}

int main() {
	ios::sync_with_stdio(false);
	cin.tie(0);
	ll ans = 0;
	int n, k;
	cin &gt;&gt; n &gt;&gt; k;
	v.resize(n);
	for(int i = 0; i &lt; n; ++i) cin &gt;&gt; v[i];
	sort(v.begin(), v.end());
	for(int i = 0; i &lt; n; ++i) {
		int nxt = bsh(i, n - 1, v[i] + k);
		if(v[nxt] == v[i] + k) {
			ll len = nxt - i + 1 - 2;
			ans = (ans + qp(2, len)) % mod;
		}
	}
	cout &lt;&lt; ans &lt;&lt; '\n';
	return 0;
}
</code></pre>
<h3 id="t4-求和">T4 求和</h3>
<p>对于比较大的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>采用暴力求,为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="script">O</mi><mo>(</mo><mfrac><mi>n</mi><mi>k</mi></mfrac><mo>)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O(\frac{n}{k})}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.095em;vertical-align:-0.345em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.695392em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">)</span></span></span></span></span>。<br>
比较小的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>打个表预处理。<br>
当<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>取到<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msqrt><mi>n</mi></msqrt></mrow><annotation encoding="application/x-tex">\sqrt{n}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.04em;vertical-align:-0.23972em;"></span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8002800000000001em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord" style="padding-left:0.833em;"><span class="mord mathdefault">n</span></span></span><span style="top:-2.76028em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="min-width:0.853em;height:1.08em;"><svg width='400em' height='1.08em' viewBox='0 0 400000 1080' preserveAspectRatio='xMinYMin slice'><path d='M95,702c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,
-10,-9.5,-14c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54c44.2,-33.3,65.8,
-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10s173,378,173,378c0.7,0,
35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429c69,-144,104.5,-217.7,106.5,
-221c5.3,-9.3,12,-14,20,-14H400000v40H845.2724s-225.272,467,-225.272,467
s-235,486,-235,486c-2.7,4.7,-9,7,-19,7c-6,0,-10,-1,-12,-3s-194,-422,-194,-422
s-65,47,-65,47z M834 80H400000v40H845z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.23972em;"><span></span></span></span></span></span></span></span></span>的时候从数学上讲对随机数据是理论最快的。<br>
复杂度<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="script">O</mi><mo>(</mo><mi>q</mi><msqrt><mi>n</mi></msqrt><mo>)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O(q\sqrt{n})}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.05028em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8002800000000001em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord" style="padding-left:0.833em;"><span class="mord mathdefault">n</span></span></span><span style="top:-2.76028em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="min-width:0.853em;height:1.08em;"><svg width='400em' height='1.08em' viewBox='0 0 400000 1080' preserveAspectRatio='xMinYMin slice'><path d='M95,702c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,
-10,-9.5,-14c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54c44.2,-33.3,65.8,
-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10s173,378,173,378c0.7,0,
35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429c69,-144,104.5,-217.7,106.5,
-221c5.3,-9.3,12,-14,20,-14H400000v40H845.2724s-225.272,467,-225.272,467
s-235,486,-235,486c-2.7,4.7,-9,7,-19,7c-6,0,-10,-1,-12,-3s-194,-422,-194,-422
s-65,47,-65,47z M834 80H400000v40H845z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.23972em;"><span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span>。</p>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;

using namespace std;

typedef long long ll;

const int bis = 315, maxn = 123456;
int a[maxn];
ll kd[bis + 10][bis + 10];

int main() {
	int n, q, k, b;
	scanf(&quot;%d %d&quot;, &amp;n, &amp;q);
	for(int i = 1; i &lt;= n; ++i)
		scanf(&quot;%d&quot;, a + i);
	for(int i = 1; i &lt;= n; ++i) {
		for(int j = 1; j &lt;= bis; ++j) {
			kd[j][i % j] += a[i];
		}
	}
	while(q--) {
		scanf(&quot;%d %d&quot;, &amp;k, &amp;b);
		if(k &lt;= bis) {
			if(b &gt; k) printf(&quot;0\n&quot;);
			else printf(&quot;%lld\n&quot;, kd[k][b]);
		} else {
			ll ans = 0;
			for(int i = 0; ((ll)i * k + b) &lt;= n; ++i) {
				ans = ans + a[i * k + b];
			}
			printf(&quot;%lld\n&quot;, ans);
		}
	}
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[题解 [起跑线]提高模拟Round3]]></title>
        <id>https://froldh.github.io/post/qpx-tg-round3/</id>
        <link href="https://froldh.github.io/post/qpx-tg-round3/">
        </link>
        <updated>2020-02-26T14:45:05.000Z</updated>
        <summary type="html"><![CDATA[<p>Rnk3  T1、T2连续翻车丢人<br>
60 + 20 + 100</p>
]]></summary>
        <content type="html"><![CDATA[<p>Rnk3  T1、T2连续翻车丢人<br>
60 + 20 + 100</p>
<!-- more -->  
<h3 id="t1-简单问题">T1 简单问题</h3>
<p>给定 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo separator="true">,</mo><mi>k</mi></mrow><annotation encoding="application/x-tex">a,k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>，请你求出 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>a</mi><mn>1</mn></msup><mo>+</mo><msup><mi>a</mi><mn>2</mn></msup><mo>+</mo><msup><mi>a</mi><mn>3</mn></msup><mo>+</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo>+</mo><msup><mi>a</mi><mi>k</mi></msup></mrow><annotation encoding="application/x-tex">a^1+a^2+a^3+...+a^k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.849108em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span></span></span></span> 对 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>998244353</mn></mrow><annotation encoding="application/x-tex">998244353</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">9</span><span class="mord">9</span><span class="mord">8</span><span class="mord">2</span><span class="mord">4</span><span class="mord">4</span><span class="mord">3</span><span class="mord">5</span><span class="mord">3</span></span></span></span> 取模后的结果。<br>
由高中数学知识, 当<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mpadded width="0px"><mo></mo></mpadded><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">a \not = 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel"><span class="mord"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.69444em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="rlap"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="inner"><span class="mrel"></span></span><span class="fix"></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span></span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>时结果等于 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mover accent="true"><mfrac><mrow><msup><mi>a</mi><mi>k</mi></msup><mo>−</mo><mn>1</mn></mrow><mrow><mi>a</mi><mo>−</mo><mn>1</mn></mrow></mfrac><mo>˙</mo></mover></mrow><annotation encoding="application/x-tex">a \dot \frac{a^k-1}{a-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.581611em;vertical-align:-0.403331em;"></span><span class="mord mathdefault">a</span><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.17828em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9414199999999999em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">a</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight">a</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7820285714285713em;"><span style="top:-2.786em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.403331em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span><span style="top:-3.51042em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.13889em;">˙</span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.403331em;"><span></span></span></span></span></span></span></span></span>, <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">a = 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>时结果等于 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>.</p>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;

using namespace std;

typedef long long ll;

const ll mod = 998244353;

ll qp(ll a, ll b) {
   ll res = 1 % mod;
   for(; b; b &gt;&gt;= 1) {
   	if(b &amp; 1) res = res * a % mod;
   	a = a * a % mod;
   }
   return res;
}

int main() {
   ios::sync_with_stdio(false);
   cin.tie(0);
   ll a, k;
   cin &gt;&gt; a &gt;&gt; k;
   a %= mod;
   if(a == 1) cout &lt;&lt; (k % mod) &lt;&lt; '\n';
   else { 
   	ll res = a * (qp(a, k) - 1) % mod;
   	res = res * qp(a - 1, mod - 2) % mod;
   	cout &lt;&lt; res &lt;&lt; '\n';
   }
   return 0;
}
</code></pre>
<h3 id="t2-权值覆盖问题">T2 权值覆盖问题</h3>
<p>并查集写法挂掉了，题解给的是差分约束。<br>
等弄明白想法对不对再补上罢，咕咕咕。。。</p>
<h3 id="t3-删边问题">T3 删边问题</h3>
<p>套路化的离线解法，把删边看作是加边，然后对加边的情况进行讨论和更新(和BFS一致)即可。</p>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;

using namespace std;

const int inf = 0x3f3f3f3f;

struct edge {
	int u, v;
	edge() {}
	edge(int U, int V) : u(U), v(V) {}
};
vector&lt;edge&gt; edges;
vector&lt; vector&lt;int&gt; &gt; e, e_raw;
vector&lt;int&gt; del, ans, dis, dis_raw;
vector&lt;bool&gt; isdel;

queue&lt;int&gt; que;
void bfs_raw() {
	dis_raw[1] = 0;
	que.push(1);
	while(!que.empty()) {
		int cur = que.front(); que.pop();
		for(int ver : e_raw[cur]) {
			if(inf == dis_raw[ver]) {
				dis_raw[ver] = dis_raw[cur] + 1;
				que.push(ver); 
			}
		}
	}

}

void bfs_end() {
	dis[1] = 0;
	que.push(1);
	while(!que.empty()) {
		int cur = que.front(); que.pop();
		for(int ver : e[cur]) {
			if(inf == dis[ver]) {
				dis[ver] = dis[cur] + 1;
				que.push(ver);	
			}
		}
	}
}

int main() {
	ios::sync_with_stdio(false);
	cin.tie(0);
	int n, m, q, tmp, u, v;
	cin &gt;&gt; n &gt;&gt; m &gt;&gt; q;
	isdel.assign(m, false);
	edges.resize(m);
	e_raw.resize(n + 1);
	e.resize(n + 1);
	dis.assign(n + 1, inf);
	dis_raw.resize(n + 1, inf);
	ans.resize(q + 1);
	for(int i = 0; i &lt; m; ++i) {
		cin &gt;&gt; u &gt;&gt; v;
		edges[i] = edge(u, v);
		e_raw[u].push_back(v);
		e_raw[v].push_back(u);
	}
	for(int i = 0; i &lt; q; ++i) {
		cin &gt;&gt; tmp;
		--tmp;
		if(!isdel[tmp]) {
			isdel[tmp] = true;
			del.push_back(tmp);
		} else {
			del.push_back(-1);
		}
	}
	bfs_raw();
	for(int i = 0; i &lt; m; ++i)
		if(!isdel[i]) {
			e[edges[i].u].push_back(edges[i].v);
			e[edges[i].v].push_back(edges[i].u);
		}
	bfs_end();
	for(int i = 1; i &lt;= n; ++i)
		if(dis[i] != dis_raw[i])
			++ans[q];
	for(int i = q - 1; ~i; --i) {
		ans[i] = ans[i + 1];
		if(!~del[i]) continue;
		u = edges[del[i]].u, v = edges[del[i]].v;
		e[u].push_back(v);
		e[v].push_back(u);
		if(abs(dis[u] - dis[v]) &lt;= 1)
			continue;
		if(dis[u] &lt; dis[v]) swap(u, v);
		dis[u] = dis[v] + 1;
		if(dis[u] == dis_raw[u]) --ans[i];
		que.push(u);
		while(!que.empty()) {
			int cur = que.front(); que.pop();
			for(int ver : e[cur]) {
				if(dis[ver] &gt; dis[cur] + 1) {
					dis[ver] = dis[cur] + 1;
					if(dis[ver] == dis_raw[ver]) --ans[i];
					que.push(ver);
				}
			}
		}
	}
	for(int i = 1; i &lt;= q; ++i) cout &lt;&lt; ans[i] &lt;&lt; '\n';
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[题解 [起跑线]普及模拟Round4]]></title>
        <id>https://froldh.github.io/post/qpx-pj-round4/</id>
        <link href="https://froldh.github.io/post/qpx-pj-round4/">
        </link>
        <updated>2020-02-25T14:13:37.000Z</updated>
        <summary type="html"><![CDATA[<p>T2 fst Rnk8 丢人了</p>
]]></summary>
        <content type="html"><![CDATA[<p>T2 fst Rnk8 丢人了</p>
<!-- more -->  
<h3 id="t1-追击问题">T1 追击问题</h3>
<p>判断位移和相对速度方向是否一致即可。</p>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;

using namespace std;

typedef long long ll;

int main() {
	ios::sync_with_stdio(false);
	cin.tie(0);
	ll x, a, y, b;
	cin &gt;&gt; x &gt;&gt; a &gt;&gt; y &gt;&gt; b;
	if((x - y) * (a - b) &lt; 0) {
		cout &lt;&lt; &quot;YES&quot; &lt;&lt; '\n';	
	} else {
		cout &lt;&lt; &quot;NO&quot; &lt;&lt; '\n';
	}
	return 0;
}
</code></pre>
<h3 id="t2-最短路问题">T2 最短路问题</h3>
<p>如果没有额外的边，直接在图上跑BFS即可。<br>
对于特殊边，显然，如果一个集合的某点先被访问，那么其他点到另一个集合的边就没有更新距离的作用了。所以实际上有效的边只有<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="script">O</mi><mo>(</mo><mi>a</mi><mo>+</mo><mi>b</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O(a + b)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">b</span><span class="mclose">)</span></span></span></span></span>而不是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="script">O</mi><mo>(</mo><mi>a</mi><mi>b</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O(ab)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mord mathdefault">b</span><span class="mclose">)</span></span></span></span></span>。<br>
所以动态判断这些边的处理即可。<br>
复杂度<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="script">O</mi><mo>(</mo><mi>n</mi><mo>+</mo><mi>m</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O(n + m)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">m</span><span class="mclose">)</span></span></span></span></span></p>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;

using namespace std;

vector&lt; vector&lt;int&gt; &gt; edge;
vector&lt;int&gt; dis, c, d;
vector&lt;bool&gt; isC, isD;

queue&lt;int&gt; q;
void bfs() {
	bool visc = false, visd = false;
	q.push(1);
	dis[1] = 0;
	while(!q.empty()) {
		int cur = q.front(); q.pop();
		for(int ver : edge[cur])
			if(!~dis[ver]) {
				dis[ver] = dis[cur] + 1;
				q.push(ver);
			}
		if(isC[cur] &amp;&amp; !visd) {
			visd = true;
			for(int ver : d)
				if(!~dis[ver]) {
					dis[ver] = dis[cur] + 1;	
					q.push(ver);
				}
		}
		if(isD[cur] &amp;&amp; !visc) {
			visc = true;
			for(int ver : c)
				if(!~dis[ver]) {
					dis[ver] = dis[cur] + 1;
					q.push(ver);	
				}
		}
	}
}

int main() {
	ios::sync_with_stdio(false);
	cin.tie(0);
	int n, m, a, b, tmp, u, v;
	cin &gt;&gt; n &gt;&gt; m;
	edge.resize(n + 1);
	dis.assign(n + 1, -1);
	isC.assign(n, false);
	isD.assign(n, false);
	for(int i = 1; i &lt;= m; ++i) {
		cin &gt;&gt; u &gt;&gt; v;
		edge[u].push_back(v);
		edge[v].push_back(u);
	}
	cin &gt;&gt; a &gt;&gt; b;
	c.resize(a);
	d.resize(b);
	for(int i = 0; i &lt; a; ++i) {
		cin &gt;&gt; tmp;
		isC[tmp] = true;
		c[i] = tmp;
	}
	for(int i = 0; i &lt; b; ++i) {
		cin &gt;&gt; tmp;
		isD[tmp] = true;
		d[i] = tmp;
	}
	bfs();
	for(int i = 1; i &lt;= n; ++i)
		cout &lt;&lt; dis[i] &lt;&lt; '\n';
	return 0;
}
</code></pre>
<h3 id="t3-数码问题">T3 数码问题</h3>
<p>咕咕咕。。。</p>
<h3 id="t4-三角形问题">T4 三角形问题</h3>
<p>考虑构造最小的不能满足三角形的数列。<br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mo separator="true">,</mo><mn>1</mn><mo separator="true">,</mo><mn>2</mn><mo separator="true">,</mo><mn>3</mn><mo separator="true">,</mo><mn>5</mn><mo separator="true">,</mo><mn>8</mn><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">1, 1, 2, 3, 5, 8, ...</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">5</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">8</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span></span></span></span><br>
事斐波那契！<br>
第84项斐波那契<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>⩾</mo><mn>1</mn><msup><mn>0</mn><mn>18</mn></msup></mrow><annotation encoding="application/x-tex">\geqslant 10^{18}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7733399999999999em;vertical-align:-0.13667em;"></span><span class="mrel amsrm">⩾</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">8</span></span></span></span></span></span></span></span></span></span></span></span>, 根据抽屉原理, 树上路径长度<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>⩾</mo><mn>84</mn></mrow><annotation encoding="application/x-tex">\geqslant 84</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7733399999999999em;vertical-align:-0.13667em;"></span><span class="mrel amsrm">⩾</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">8</span><span class="mord">4</span></span></span></span>的一定能构成。<br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>⩽</mo><mn>84</mn></mrow><annotation encoding="application/x-tex">\leqslant 84</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7733399999999999em;vertical-align:-0.13667em;"></span><span class="mrel amsrm">⩽</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">8</span><span class="mord">4</span></span></span></span>的路径直接暴力求点权。<br>
复杂度<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="script">O</mi><mo>(</mo><mo>(</mo><mi>q</mi><mo>+</mo><mi>n</mi><mo>)</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O((q + n)logn)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></span></p>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;

using namespace std;

typedef long long ll;

const int maxn = 567890;
int t[maxn], k[maxn], b[maxn], head[maxn], ver[maxn&lt;&lt;1], nex[maxn&lt;&lt;1], tot;
inline void addedge(int u, int v) {
	ver[tot] = v; nex[tot] = head[u]; head[u] = tot++;	
}
int n, q;

int fa[maxn][32], dep[maxn];
void dfs(int cur, int pre) {
	dep[cur] = dep[pre] + 1; fa[cur][0] = pre;
	for(int i = 1; i &lt;= 30; ++i) fa[cur][i] = fa[fa[cur][i-1]][i-1];
	for(int i = head[cur]; ~i; i = nex[i])
		if(!dep[ver[i]]) dfs(ver[i], cur);
	
}

int lca(int u, int v) {
	if(dep[u] &lt; dep[v])	swap(u, v);
	for(int i = 30; ~i; --i) 
		if(dep[fa[u][i]] &gt;= dep[v])	u = fa[u][i];
	if(u == v) return u;
	for(int i = 30; ~i; --i)
		if(fa[u][i] != fa[v][i])
			u = fa[u][i], v = fa[v][i];
	return fa[u][0];
}

int main() {
	srand((unsigned)time(0));
	memset(head, -1, sizeof(head));
	ios::sync_with_stdio(false);
	cin.tie(0);
	int u, v;
	ll x;
	cin &gt;&gt; n;
	for(int i = 1; i &lt;= n; ++i)
		cin	&gt;&gt; t[i] &gt;&gt; k[i] &gt;&gt; b[i];
	for(int i = 1; i &lt; n; ++i) {
		cin &gt;&gt; u &gt;&gt; v;
		addedge(u, v);
		addedge(v, u);
	}
	dfs(1, 1);
	cin &gt;&gt; q;
	while(q--) {
		cin &gt;&gt; u &gt;&gt; v &gt;&gt; x;
		int lc = lca(u, v);
		if(-2 * dep[lc] + dep[v] + dep[u] + 1 &gt;= 84)
			cout &lt;&lt; &quot;YES&quot; &lt;&lt; '\n';
		else if(u == v) {
			cout &lt;&lt; &quot;NO&quot; &lt;&lt; '\n';
		} else {
			vector&lt;ll&gt; vec;
			while(u != lc) {
				vec.push_back(x * x * t[u] + x * k[u] + b[u]);
				u = fa[u][0];
			}
			while(v != lc) {
				vec.push_back(x * x * t[v] + x * k[v] + b[v]);
				v = fa[v][0];
			}
			vec.push_back(x * x * t[lc] + x * k[lc] + b[lc]);
			random_shuffle(vec.begin(), vec.end());
			bool flg = true;
			for(int i = 0; flg &amp;&amp; i &lt; vec.size(); ++i)
				for(int j = 0; flg &amp;&amp; j &lt; vec.size(); ++j)
					for(int k = 0; flg &amp;&amp; k &lt; vec.size(); ++k)
						if(i &lt; j &amp;&amp; j &lt; k) {
							ll sum = vec[i] + vec[j] + vec[k];
							ll mx = max(max(vec[i], vec[j]), vec[k]);
							if(sum - mx &gt; mx) {
								flg = false;
								break;	
							}
						}
			if(!flg) {
				cout &lt;&lt; &quot;YES&quot; &lt;&lt; '\n';	
			} else {
				cout &lt;&lt; &quot;NO&quot;&lt;&lt; '\n';	
			}
		}
	}
	return 0;
} 
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[题解 [起跑线]提高模拟Round2]]></title>
        <id>https://froldh.github.io/post/qpx-tg-round2/</id>
        <link href="https://froldh.github.io/post/qpx-tg-round2/">
        </link>
        <updated>2020-02-25T09:40:29.000Z</updated>
        <summary type="html"><![CDATA[<p>三题暴力拿Rnk5很丢人的好伐</p>
]]></summary>
        <content type="html"><![CDATA[<p>三题暴力拿Rnk5很丢人的好伐</p>
<!-- more -->
<h3 id="t1-数论">T1 数论</h3>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>⩽</mo><mn>20</mn></mrow><annotation encoding="application/x-tex">n \leqslant 20</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7733399999999999em;vertical-align:-0.13667em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel amsrm">⩽</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">0</span></span></span></span> ,  枚举所有倍数容斥原理做即可。 复杂度<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="script">O</mi><mo>(</mo><msup><mn mathvariant="script">2</mn><mi>n</mi></msup><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>r</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O(2^n nlogr)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathcal">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mclose">)</span></span></span></span></span></p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

using namespace std;

typedef long long ll;

vector&lt;ll&gt; v;
ll ans = 0, l, r;
int n;

void dfs(int cur, ll lcm, int sign) {
	if(cur == n) {
		ans += (r / lcm  - (l - 1) / lcm) * sign;
		return;
	}
	dfs(cur + 1, lcm, sign);
	ll g = __gcd(lcm, v[cur]);
	if((double)lcm / g * v[cur] &lt;= r)
		dfs(cur + 1, lcm / g * v[cur], -sign);
}

int main() {
	ios::sync_with_stdio(false);
	cin.tie(0);
	cin &gt;&gt; n &gt;&gt; l &gt;&gt; r;
	v.resize(n);
	for(int i = 0; i &lt; n; ++i)
		cin &gt;&gt; v[i];
	dfs(0, 1, 1);
	cout &lt;&lt; r - l + 1 - ans &lt;&lt; '\n'; 
	return 0;
}
</code></pre>
<h3 id="t2-术论">T2 术论</h3>
<p>正在咕。。。</p>
<h3 id="t3-数论">T3 数论</h3>
<p>正在咕。。。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[笔记 容斥原理]]></title>
        <id>https://froldh.github.io/post/rong-chi-yuan-li-bi-ji/</id>
        <link href="https://froldh.github.io/post/rong-chi-yuan-li-bi-ji/">
        </link>
        <updated>2020-02-25T06:05:40.000Z</updated>
        <summary type="html"><![CDATA[<p>关于容斥原理的学习笔记</p>
]]></summary>
        <content type="html"><![CDATA[<p>关于容斥原理的学习笔记</p>
<!-- more -->
<h3 id="原理">原理</h3>
<h4 id="公式摘自oi-wiki">公式(摘自OI-Wiki) :</h4>
<p>设 U 中元素有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 种不同的属性，而第 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 种属性称为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">P_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> ，拥有属性<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">P_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的元素构成集合 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>S</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">S_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> ，那么所有元素的并集大小为 :<br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle scriptlevel="0" displaystyle="true"><mrow><mo fence="true">∣</mo><munderover><mo>⋃</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><msub><mi>S</mi><mi>i</mi></msub><mo fence="true">∣</mo></mrow><mo>=</mo><munderover><mo>∑</mo><mrow><mi>m</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><mo>(</mo><mo>−</mo><mn>1</mn><msup><mo>)</mo><mrow><mi>m</mi><mo>−</mo><mn>1</mn></mrow></msup><munder><mo>∑</mo><mrow><msub><mi>a</mi><mi>i</mi></msub><mo>&lt;</mo><msub><mi>a</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow></munder><mrow><mo fence="true">∣</mo><munderover><mo>⋂</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>m</mi></munderover><msub><mi>S</mi><msub><mi>a</mi><mi>i</mi></msub></msub><mo fence="true">∣</mo></mrow></mstyle></mrow><annotation encoding="application/x-tex">\displaystyle \left| \bigcup_{i=1}^{n} S_i \right| = \sum_{m=1}^{n}(-1)^{m-1}\sum_{a_i &lt; a_{i + 1}} \left| \bigcap_{i=1}^{m} S_{a_i} \right|</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:3.057644em;vertical-align:-1.277669em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.7799749999999999em;"><span style="top:-1.355975em;"><span class="pstrut" style="height:2.606em;"></span><span class="delimsizinginner delim-size1"><span>∣</span></span></span><span style="top:-1.9619749999999998em;"><span class="pstrut" style="height:2.606em;"></span><span class="delimsizinginner delim-size1"><span>∣</span></span></span><span style="top:-2.5679749999999997em;"><span class="pstrut" style="height:2.606em;"></span><span class="delimsizinginner delim-size1"><span>∣</span></span></span><span style="top:-3.173975em;"><span class="pstrut" style="height:2.606em;"></span><span class="delimsizinginner delim-size1"><span>∣</span></span></span><span style="top:-3.779975em;"><span class="pstrut" style="height:2.606em;"></span><span class="delimsizinginner delim-size1"><span>∣</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.250025em;"><span></span></span></span></span></span></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6513970000000002em;"><span style="top:-1.872331em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.050005em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">⋃</span></span></span><span style="top:-4.3000050000000005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.277669em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.7799749999999999em;"><span style="top:-1.355975em;"><span class="pstrut" style="height:2.606em;"></span><span class="delimsizinginner delim-size1"><span>∣</span></span></span><span style="top:-1.9619749999999998em;"><span class="pstrut" style="height:2.606em;"></span><span class="delimsizinginner delim-size1"><span>∣</span></span></span><span style="top:-2.5679749999999997em;"><span class="pstrut" style="height:2.606em;"></span><span class="delimsizinginner delim-size1"><span>∣</span></span></span><span style="top:-3.173975em;"><span class="pstrut" style="height:2.606em;"></span><span class="delimsizinginner delim-size1"><span>∣</span></span></span><span style="top:-3.779975em;"><span class="pstrut" style="height:2.606em;"></span><span class="delimsizinginner delim-size1"><span>∣</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.250025em;"><span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:3.171745em;vertical-align:-1.3917700000000002em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6513970000000002em;"><span style="top:-1.882887em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">m</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.050005em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3000050000000005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.267113em;"><span></span></span></span></span></span><span class="mopen">(</span><span class="mord">−</span><span class="mord">1</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.864108em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">m</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.050005em;"><span style="top:-1.8999949999999997em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3280857142857143em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mrel mtight">&lt;</span><span class="mord mtight"><span class="mord mathdefault mtight">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32808571428571426em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.20252142857142857em;"><span></span></span></span></span></span></span></span></span></span><span style="top:-3.0500049999999996em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.3917700000000002em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.7799749999999999em;"><span style="top:-1.355975em;"><span class="pstrut" style="height:2.606em;"></span><span class="delimsizinginner delim-size1"><span>∣</span></span></span><span style="top:-1.9619749999999998em;"><span class="pstrut" style="height:2.606em;"></span><span class="delimsizinginner delim-size1"><span>∣</span></span></span><span style="top:-2.5679749999999997em;"><span class="pstrut" style="height:2.606em;"></span><span class="delimsizinginner delim-size1"><span>∣</span></span></span><span style="top:-3.173975em;"><span class="pstrut" style="height:2.606em;"></span><span class="delimsizinginner delim-size1"><span>∣</span></span></span><span style="top:-3.779975em;"><span class="pstrut" style="height:2.606em;"></span><span class="delimsizinginner delim-size1"><span>∣</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.250025em;"><span></span></span></span></span></span></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6513970000000002em;"><span style="top:-1.872331em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.050005em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">⋂</span></span></span><span style="top:-4.3000050000000005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">m</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.277669em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139199999999997em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3280857142857143em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2501em;"><span></span></span></span></span></span></span><span class="mclose"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.7799749999999999em;"><span style="top:-1.355975em;"><span class="pstrut" style="height:2.606em;"></span><span class="delimsizinginner delim-size1"><span>∣</span></span></span><span style="top:-1.9619749999999998em;"><span class="pstrut" style="height:2.606em;"></span><span class="delimsizinginner delim-size1"><span>∣</span></span></span><span style="top:-2.5679749999999997em;"><span class="pstrut" style="height:2.606em;"></span><span class="delimsizinginner delim-size1"><span>∣</span></span></span><span style="top:-3.173975em;"><span class="pstrut" style="height:2.606em;"></span><span class="delimsizinginner delim-size1"><span>∣</span></span></span><span style="top:-3.779975em;"><span class="pstrut" style="height:2.606em;"></span><span class="delimsizinginner delim-size1"><span>∣</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.250025em;"><span></span></span></span></span></span></span></span></span></span></span><br>
若求交集，则利用全集减去补集的并集 :<br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle scriptlevel="0" displaystyle="true"><mrow><mo fence="true">∣</mo><munderover><mo>⋂</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><msub><mi>S</mi><mi>i</mi></msub><mo fence="true">∣</mo></mrow><mo>=</mo><mrow><mo fence="true">∣</mo><mi>U</mi><mo fence="true">∣</mo></mrow><mo>−</mo><mrow><mo fence="true">∣</mo><munderover><mo>⋃</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><msubsup><mi mathvariant="normal">∁</mi><mi>U</mi><msub><mi>S</mi><mi>i</mi></msub></msubsup><mo fence="true">∣</mo></mrow></mstyle></mrow><annotation encoding="application/x-tex">\displaystyle \left| \bigcap_{i=1}^{n} S_i \right| = \left| U \right| - \left| \bigcup_{i=1}^{n} \complement_U^{S_i} \right|</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:3.057644em;vertical-align:-1.277669em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.7799749999999999em;"><span style="top:-1.355975em;"><span class="pstrut" style="height:2.606em;"></span><span class="delimsizinginner delim-size1"><span>∣</span></span></span><span style="top:-1.9619749999999998em;"><span class="pstrut" style="height:2.606em;"></span><span class="delimsizinginner delim-size1"><span>∣</span></span></span><span style="top:-2.5679749999999997em;"><span class="pstrut" style="height:2.606em;"></span><span class="delimsizinginner delim-size1"><span>∣</span></span></span><span style="top:-3.173975em;"><span class="pstrut" style="height:2.606em;"></span><span class="delimsizinginner delim-size1"><span>∣</span></span></span><span style="top:-3.779975em;"><span class="pstrut" style="height:2.606em;"></span><span class="delimsizinginner delim-size1"><span>∣</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.250025em;"><span></span></span></span></span></span></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6513970000000002em;"><span style="top:-1.872331em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.050005em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">⋂</span></span></span><span style="top:-4.3000050000000005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.277669em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.7799749999999999em;"><span style="top:-1.355975em;"><span class="pstrut" style="height:2.606em;"></span><span class="delimsizinginner delim-size1"><span>∣</span></span></span><span style="top:-1.9619749999999998em;"><span class="pstrut" style="height:2.606em;"></span><span class="delimsizinginner delim-size1"><span>∣</span></span></span><span style="top:-2.5679749999999997em;"><span class="pstrut" style="height:2.606em;"></span><span class="delimsizinginner delim-size1"><span>∣</span></span></span><span style="top:-3.173975em;"><span class="pstrut" style="height:2.606em;"></span><span class="delimsizinginner delim-size1"><span>∣</span></span></span><span style="top:-3.779975em;"><span class="pstrut" style="height:2.606em;"></span><span class="delimsizinginner delim-size1"><span>∣</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.250025em;"><span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">∣</span><span class="mord mathdefault" style="margin-right:0.10903em;">U</span><span class="mclose delimcenter" style="top:0em;">∣</span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:3.057644em;vertical-align:-1.277669em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.7799749999999999em;"><span style="top:-1.355975em;"><span class="pstrut" style="height:2.606em;"></span><span class="delimsizinginner delim-size1"><span>∣</span></span></span><span style="top:-1.9619749999999998em;"><span class="pstrut" style="height:2.606em;"></span><span class="delimsizinginner delim-size1"><span>∣</span></span></span><span style="top:-2.5679749999999997em;"><span class="pstrut" style="height:2.606em;"></span><span class="delimsizinginner delim-size1"><span>∣</span></span></span><span style="top:-3.173975em;"><span class="pstrut" style="height:2.606em;"></span><span class="delimsizinginner delim-size1"><span>∣</span></span></span><span style="top:-3.779975em;"><span class="pstrut" style="height:2.606em;"></span><span class="delimsizinginner delim-size1"><span>∣</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.250025em;"><span></span></span></span></span></span></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6513970000000002em;"><span style="top:-1.872331em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.050005em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">⋃</span></span></span><span style="top:-4.3000050000000005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.277669em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord amsrm">∁</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9232309999999999em;"><span style="top:-2.4064690000000004em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.10903em;">U</span></span></span><span style="top:-3.1449em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3280857142857143em;"><span style="top:-2.357em;margin-left:-0.05764em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.29353099999999993em;"><span></span></span></span></span></span></span><span class="mclose"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.7799749999999999em;"><span style="top:-1.355975em;"><span class="pstrut" style="height:2.606em;"></span><span class="delimsizinginner delim-size1"><span>∣</span></span></span><span style="top:-1.9619749999999998em;"><span class="pstrut" style="height:2.606em;"></span><span class="delimsizinginner delim-size1"><span>∣</span></span></span><span style="top:-2.5679749999999997em;"><span class="pstrut" style="height:2.606em;"></span><span class="delimsizinginner delim-size1"><span>∣</span></span></span><span style="top:-3.173975em;"><span class="pstrut" style="height:2.606em;"></span><span class="delimsizinginner delim-size1"><span>∣</span></span></span><span style="top:-3.779975em;"><span class="pstrut" style="height:2.606em;"></span><span class="delimsizinginner delim-size1"><span>∣</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.250025em;"><span></span></span></span></span></span></span></span></span></span></span></p>
<h4 id="感性理解">感性理解 :</h4>
<p>求并集，需要不断地把重复统计的元素减去。<br>
全集减去补集的并的部分即为所有补集都没有的部分，换言之，时所有原集合共有的部分，即交集。</p>
<h3 id="一般实现方法">一般实现方法 :</h3>
<p>通过枚举所有的选取方案求容斥，一种是利用二进制表示选取的方式，一种是用dfs。</p>
<h4 id="1-dfs法">1) dfs法</h4>
<pre><code class="language-cpp">//借鉴jiangly神仙的代码改编
Number ans;
void dfs(int cur, int sign, Number valueState) {
	if(cur == n) {
		ans += valueState;
		return;
	}
	dfs(cur + 1, sign, valueState);    //不选
	dfs(cur + 1，-sign, valueState + calc(cur)); //选择
}

signed main() {
    ...
    dfs(0, 1, ...);
    ...
}
</code></pre>
<h4 id="2-二进制枚举">2) 二进制枚举</h4>
<p>正在咕。。。</p>
<h4 id="3-数组模拟二进制">3) 数组模拟二进制</h4>
<p>正在咕。。。</p>
<h3 id="应用">应用</h3>
<p>正在咕。。。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[题解 luoguP2002 消息扩散]]></title>
        <id>https://froldh.github.io/post/ti-jie-luogup2002-xiao-xi-kuo-san/</id>
        <link href="https://froldh.github.io/post/ti-jie-luogup2002-xiao-xi-kuo-san/">
        </link>
        <updated>2020-01-11T15:29:26.000Z</updated>
        <summary type="html"><![CDATA[<p>跑个tarjan缩点。然后同一个scc的点可以互传。</p>
]]></summary>
        <content type="html"><![CDATA[<p>跑个tarjan缩点。然后同一个scc的点可以互传。</p>
<!--more-->  
<p>缩点后是一个DAG,然后只要向入度为0的点传信息即可。</p>
<p>细节:</p>
<ol>
<li>在实现时统计入度,要判断边的起点和终点是否在同一个scc中,是的话不要加入度</li>
<li>很多题解都说要特判自环,实际上不需要的,强连通分量的含义是极大的强连通子图。</li>
</ol>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;cstring&gt;

using namespace std;

const int N = 123456, M = 567890;
int head[N], ver[M], nex[M], my[M], tot;
inline void addedge(int u, int v) {
    ver[tot] = v; my[tot] = u; nex[tot] = head[u]; head[u] = tot++;
}

int co[N], dfn[N], low[N], sta[N], ind[N], top, dfs_clock = 1, col = 1;
void tarjan(int cur) {
    dfn[cur] = low[cur] = dfs_clock++;
    sta[top++] = cur;
    for(int i = head[cur]; ~i; i = nex[i]) {
        if(!dfn[ver[i]]) {
            tarjan(ver[i]);
            low[cur] = min(low[cur], low[ver[i]]);
        } else if(!co[ver[i]]) {
            low[cur] = min(low[cur], dfn[ver[i]]);
        }
    }
    if(dfn[cur] == low[cur]) {
        while(sta[--top] != cur) {
            co[sta[top]] = col;
        }
        co[cur] = col++;
    }
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    memset(head, -1, sizeof(head));
    memset(ind, 0, sizeof(ind));
    int n, m, u, v, cnt = 0;
    cin &gt;&gt; n &gt;&gt; m;
    for(int i = 1; i &lt;= m; ++i) {
        cin &gt;&gt; u &gt;&gt; v;
        if(u != v) addedge(u, v);
    }
    for(int i = 1; i &lt;= n; ++i) if(!co[i]) tarjan(i);
    for(int i = 0; i &lt; tot; ++i) if(co[my[i]] != co[ver[i]]) ind[co[ver[i]]] = 1;
    for(int i = 1; i &lt; col; ++i)
        if(!ind[i]) ++cnt;
    cout &lt;&lt; cnt &lt;&lt; '\n';
    return 0;
}

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[题解 [XJOI] CSP-S2开放一]]></title>
        <id>https://froldh.github.io/post/ti-jie-xjoi-csp-s2-kai-fang-yi/</id>
        <link href="https://froldh.github.io/post/ti-jie-xjoi-csp-s2-kai-fang-yi/">
        </link>
        <updated>2019-11-11T08:11:53.000Z</updated>
        <summary type="html"><![CDATA[<p>期望得分 100+100+60 = 260<br>
实际得分 30+20+70 = 120</p>
]]></summary>
        <content type="html"><![CDATA[<p>期望得分 100+100+60 = 260<br>
实际得分 30+20+70 = 120</p>
<!--more-->  
<h3 id="t1">T1</h3>
<p>实际上是个暴力枚举<br>
考场打炸了,RE30<br>
订正代码</p>
<pre><code class="language-cpp">#include &lt;cstdio&gt;
#define ll long long
 
using namespace std;
 
const int p[] = {1, 10, 100, 1000, 10000, 100000, 1000000, 10000000, 100000000};
 
int main() {
    int t;
    scanf(&quot;%d&quot;, &amp;t);
    while(t--) {
        ll cnt = 0;
        int l, r, tmp, n;
        scanf(&quot;%d %d&quot;, &amp;l, &amp;r);
        tmp = l; n = 0;
        while(tmp) {   
            tmp /= 10; ++n;
        }
        for(int i = l; i &lt;= r; ++i) {
            tmp = i;
            int low = tmp % 10; tmp /= 10; tmp += low * p[n-1];
            while(tmp != i) {
                if(low &amp;&amp; tmp &gt;= l &amp;&amp; tmp &lt;= r) ++cnt;
                low = tmp % 10; tmp /= 10; tmp += low * p[n-1];
            }
        }
        printf(&quot;%lld\n&quot;, cnt / 2);
    }
    return 0;
}
</code></pre>
<h3 id="t2">T2</h3>
<p>实际上就是最短路计数<br>
考虑把下半边折上去,就满足对称性<br>
然后跑最短路计数<br>
这里建了虚拟节点0方便统计<br>
考场上表头开小导致死循环了得分20,开大就对了<br>
RE代码</p>
<pre><code class="language-cpp">#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;queue&gt;

using namespace std;

const int N = 123, MOD = 1000000009, INF = 0x3f3f3f3f;
int a[N][N];
int head[N], ver[N*N], wei[N*N], nex[N*N], tot;
inline void addedge(int u, int v, int w) {
	ver[tot] = v, wei[tot] = w, nex[tot] = head[u], head[u] = tot++;
}

struct node{
	int x, d;
	node() {}
	node(int X, int DIS) : x(X), d(DIS) {}
	bool operator &lt; (const node&amp; o) const { return d &lt; o.d; }
};
priority_queue&lt;node&gt; q;
int dis[N*N], f[N*N];
void dij() {
	memset(dis, INF, sizeof(dis));
	memset(f, 0, sizeof(f));
	dis[1] = a[1][1]; f[1] = 1;
	q.push(node(1, dis[1]));
	while(!q.empty()) {
		node cur = q.top(); q.pop();
		if(-cur.d &gt; dis[cur.x]) continue;
		for(int i = head[cur.x]; ~i; i = nex[i])
			if(dis[ver[i]] &gt; dis[cur.x] + wei[i]) {
				dis[ver[i]] = dis[cur.x] + wei[i];
				f[ver[i]] = f[cur.x];
				q.push(node(ver[i], -dis[ver[i]]));
			} else if(dis[ver[i]] == dis[cur.x] + wei[i]) {
				f[ver[i]] = (f[cur.x] + f[ver[i]]) % MOD;
			}
				
	}
}

int main() {
	int n;
	while(~scanf(&quot;%d&quot;, &amp;n) &amp;&amp; n) {
		for(int i = 1; i &lt;= n; ++i)
			for(int j = 1; j &lt;= n; ++j) {
				scanf(&quot;%d&quot;, &amp;a[i][j]);
				if(j &gt; n+1-i) a[n+1-j][n+1-i] += a[i][j];
			}
		memset(head, -1, sizeof(head));
		tot = 0;
		for(int i = 1; i &lt;= n; ++i)
			for(int j = 1; j &lt;= n+1-i; ++j) {
					int cur = (i-1)*n+j;
					if(j != 1) addedge(cur, cur-1, a[i][j-1]);
					if(j != n+1-i) addedge(cur, cur+1, a[i][j+1]), addedge(cur, cur+n, a[i+1][j]);
					if(i != 1) addedge(cur, cur-n, a[i-1][j]);
					if(i+j == n+1) addedge((i-1)*n+j, 0, 0);
				}
		dij();
		printf(&quot;%d\n&quot;, f[0]);
	}
	return 0;
}
</code></pre>
<p>订正代码:</p>
<pre><code class="language-cpp">#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;queue&gt;

using namespace std;

const int N = 123, MOD = 1000000009, INF = 0x3f3f3f3f;
int a[N][N];
int head[N*N], ver[N*N*N], wei[N*N*N], nex[N*N*N], tot;
inline void addedge(int u, int v, int w) {
	ver[tot] = v, wei[tot] = w, nex[tot] = head[u], head[u] = tot++;
}

struct node{
	int x, d;
	node() {}
	node(int X, int DIS) : x(X), d(DIS) {}
	bool operator &lt; (const node&amp; o) const { return d &lt; o.d; }
};
priority_queue&lt;node&gt; q;
int dis[N*N], f[N*N];
void dij() {
	memset(dis, INF, sizeof(dis));
	memset(f, 0, sizeof(f));
	dis[1] = a[1][1]; f[1] = 1;
	q.push(node(1, dis[1]));
	while(!q.empty()) {
		node cur = q.top(); q.pop();
		if(-cur.d &gt; dis[cur.x]) continue;
		for(int i = head[cur.x]; ~i; i = nex[i])
			if(dis[ver[i]] &gt; dis[cur.x] + wei[i]) {
				dis[ver[i]] = dis[cur.x] + wei[i];
				f[ver[i]] = f[cur.x];
				q.push(node(ver[i], -dis[ver[i]]));
			} else if(dis[ver[i]] == dis[cur.x] + wei[i]) {
				f[ver[i]] = (f[cur.x] + f[ver[i]]) % MOD;
			}
				
	}
}

int main() {
	int n;
	while(~scanf(&quot;%d&quot;, &amp;n) &amp;&amp; n) {
		for(int i = 1; i &lt;= n; ++i)
			for(int j = 1; j &lt;= n; ++j) {
				scanf(&quot;%d&quot;, &amp;a[i][j]);
				if(j &gt; n+1-i) a[n+1-j][n+1-i] += a[i][j];
			}
		memset(head, -1, sizeof(head));
		tot = 0;
		for(int i = 1; i &lt;= n; ++i)
			for(int j = 1; j &lt;= n+1-i; ++j) {
					int cur = (i-1)*n+j;
					if(j != 1) addedge(cur, cur-1, a[i][j-1]);
					if(j != n+1-i) addedge(cur, cur+1, a[i][j+1]), addedge(cur, cur+n, a[i+1][j]);
					if(i != 1) addedge(cur, cur-n, a[i-1][j]);
					if(i+j == n+1) addedge((i-1)*n+j, 0, 0);
				}
		dij();
		printf(&quot;%d\n&quot;, f[0]);
	}
	return 0;
}
</code></pre>
<h3 id="t3">T3</h3>
<p>考场上打了个树上背包暴力<br>
70</p>
<p>70分代码,树上背包</p>
<pre><code class="language-cpp">#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;

using namespace std;

const int N = 3456;
int head[N], ver[N&lt;&lt;1], nex[N&lt;&lt;1], tot, n;
inline void addedge(int u, int v) {
	ver[tot] = v; nex[tot] = head[u]; head[u] = tot++;
}
int a[N], f[N][N], lim;
void dfs(int cur, int pre) {
	for(int i = head[cur]; ~i; i = nex[i])
		if(pre != ver[i]) {
			dfs(ver[i], cur);
			for(int j = lim; ~j; --j)
				for(int k = j; ~k; --k)
					f[cur][j] = max(f[cur][j], f[cur][j-k] + f[ver[i]][k]);
		}
	for(int i = lim; i &gt; 0; --i)
		f[cur][i] = f[cur][i-1] + a[cur];
}

int main() {
	memset(head, -1, sizeof(head));
	int u, v;
	scanf(&quot;%d %d&quot;, &amp;n, &amp;lim);
	for(int i = 1; i &lt;= n; ++i) scanf(&quot;%d&quot;, a + i);
	for(int i = 1; i &lt; n; ++i) {
		scanf(&quot;%d %d&quot;, &amp;u, &amp;v);
		addedge(u, v);
		addedge(v, u);
	}
	dfs(1, 0);
	printf(&quot;%d\n&quot;, f[1][lim]);
	return 0;
}
</code></pre>
<p>100分代码<br>
鬼知道是这种优化！！！<br>
背包范围按<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi><mi>i</mi><mi>n</mi><mo>(</mo><mi>s</mi><mi>i</mi><mi>z</mi><mi>e</mi><mo separator="true">,</mo><mi>l</mi><mi>i</mi><mi>m</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">min(size, lim)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mopen">(</span><span class="mord mathdefault">s</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="mord mathdefault">e</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">i</span><span class="mord mathdefault">m</span><span class="mclose">)</span></span></span></span>枚举</p>
<pre><code class="language-cpp">#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;queue&gt;

using namespace std;

const int N = 123, MOD = 1000000009, INF = 0x3f3f3f3f;
int a[N][N];
int head[N*N], ver[N*N*N], wei[N*N*N], nex[N*N*N], tot;
inline void addedge(int u, int v, int w) {
	ver[tot] = v, wei[tot] = w, nex[tot] = head[u], head[u] = tot++;
}

struct node{
	int x, d;
	node() {}
	node(int X, int DIS) : x(X), d(DIS) {}
	bool operator &lt; (const node&amp; o) const { return d &lt; o.d; }
};
priority_queue&lt;node&gt; q;
int dis[N*N], f[N*N];
void dij() {
	memset(dis, INF, sizeof(dis));
	memset(f, 0, sizeof(f));
	dis[1] = a[1][1]; f[1] = 1;
	q.push(node(1, dis[1]));
	while(!q.empty()) {
		node cur = q.top(); q.pop();
		if(-cur.d &gt; dis[cur.x]) continue;
		for(int i = head[cur.x]; ~i; i = nex[i])
			if(dis[ver[i]] &gt; dis[cur.x] + wei[i]) {
				dis[ver[i]] = dis[cur.x] + wei[i];
				f[ver[i]] = f[cur.x];
				q.push(node(ver[i], -dis[ver[i]]));
			} else if(dis[ver[i]] == dis[cur.x] + wei[i]) {
				f[ver[i]] = (f[cur.x] + f[ver[i]]) % MOD;
			}
				
	}
}

int main() {
	int n;
	while(~scanf(&quot;%d&quot;, &amp;n) &amp;&amp; n) {
		for(int i = 1; i &lt;= n; ++i)
			for(int j = 1; j &lt;= n; ++j) {
				scanf(&quot;%d&quot;, &amp;a[i][j]);
				if(j &gt; n+1-i) a[n+1-j][n+1-i] += a[i][j];
			}
		memset(head, -1, sizeof(head));
		tot = 0;
		for(int i = 1; i &lt;= n; ++i)
			for(int j = 1; j &lt;= n+1-i; ++j) {
					int cur = (i-1)*n+j;
					if(j != 1) addedge(cur, cur-1, a[i][j-1]);
					if(j != n+1-i) addedge(cur, cur+1, a[i][j+1]), addedge(cur, cur+n, a[i+1][j]);
					if(i != 1) addedge(cur, cur-n, a[i-1][j]);
					if(i+j == n+1) addedge((i-1)*n+j, 0, 0);
				}
		dij();
		printf(&quot;%d\n&quot;, f[0]);
	}
	return 0;
}
</code></pre>
<p>问题：细节方面很不小心,T2存图的表头开小直接TLE丢掉80分<br>
T3认为复杂度不对就没打优化,还是要敢试<br>
T1RE可能也不是特别出乎意料吧,毕竟拍都懒得拍了<br>
就这样漏洞百出我竟然还敢提前48分钟交卷<br>
总的来说应当更加仔细<br>
应该拍大数据(雾)<br>
考场上最后的时间要留出来检查表头有没有开够,以及一些初始化的细节<br>
还是考挂了自己菜,要多加油了</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[题解 luoguP1379 八数码难题]]></title>
        <id>https://froldh.github.io/post/ti-jie-luogup1379-ba-shu-ma-nan-ti/</id>
        <link href="https://froldh.github.io/post/ti-jie-luogup1379-ba-shu-ma-nan-ti/">
        </link>
        <updated>2019-11-11T00:43:05.000Z</updated>
        <summary type="html"><![CDATA[<p>看到很多神仙都是一顿A* / 双向广搜 等操作。<br>
其实状态数也没那么多</p>
]]></summary>
        <content type="html"><![CDATA[<p>看到很多神仙都是一顿A* / 双向广搜 等操作。<br>
其实状态数也没那么多</p>
<!--more-->  
<p>直接hash存储已经搜过的值,然后暴力地广搜就能过<br>
用string来表示状态,map存一下就好了</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;map&gt;
#include &lt;queue&gt;
#define pis pair&lt;int,string&gt;

using namespace std;

const string end = &quot;123804765&quot;;

inline int findZero(string s) { for(int i = 0; i &lt; 9; ++i) if(s[i] == '0') return i; }
map&lt;string, bool&gt; hash;
queue&lt;pis&gt; q;
int bfs(string start) {
	hash[start] = true;
	q.push(make_pair(0, start));
	while(!q.empty()) {
		int d = q.front().first;
		string cur = q.front().second;
		q.pop();
		if(cur == end) {
			return d;
		}
		int x = findZero(cur);
		string tmp;
		if(x / 3 != 0) {
			tmp = cur;
			swap(tmp[x], tmp[x-3]);
			if(!hash[tmp]) {
				hash[tmp] = true;
				q.push(make_pair(d + 1, tmp));
			}
		}
		if(x % 3 != 0) {
			tmp = cur;
			swap(tmp[x], tmp[x - 1]);
			if(!hash[tmp]) {
				hash[tmp] = true;
				q.push(make_pair(d + 1, tmp));
			}
		}
		if(x % 3 != 2) {
			tmp = cur;
			swap(tmp[x], tmp[x + 1]);
			if(!hash[tmp]) {
				hash[tmp] = true;
				q.push(make_pair(d + 1, tmp));
			}
		}
		if(x / 3 != 2) {
			tmp = cur;
			swap(tmp[x], tmp[x + 3]);
			if(!hash[tmp]) {
				hash[tmp] = true;
				q.push(make_pair(d + 1, tmp));
			}
		}
	}
	return -1;
}

int main() {
	ios::sync_with_stdio(false);
	string start;
	cin &gt;&gt; start;
	cout &lt;&lt; bfs(start) &lt;&lt; endl;
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[题解 luoguP3387 [模板]缩点]]></title>
        <id>https://froldh.github.io/post/title-ti-jie-luogup3387-mo-ban-suo-dian/</id>
        <link href="https://froldh.github.io/post/title-ti-jie-luogup3387-mo-ban-suo-dian/">
        </link>
        <updated>2019-11-10T13:05:33.000Z</updated>
        <summary type="html"><![CDATA[<p>tarjan缩点后形成一个DAG</p>
]]></summary>
        <content type="html"><![CDATA[<p>tarjan缩点后形成一个DAG</p>
<!--more-->
<p>然后根据tarjan的性质,缩点的编号为逆拓扑序<br>
直接按缩点编号降序DP即可</p>
<pre><code class="language-cpp">#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;

using namespace std;

const int N = 12345, M = 123456;
int head[N&lt;&lt;1], ver[M&lt;&lt;1], my[M&lt;&lt;1], nex[M&lt;&lt;1], tot;
inline void addedge(int u, int v) {
	ver[tot] = v, nex[tot] = head[u], my[tot] = u, head[u] = tot++;
}

int dfn[N], low[N], a[N], sta[N], co[N], sum[N], top, dfs_clock = 1, col = 1;
void tarjan(int cur) {
	dfn[cur] = low[cur] = dfs_clock++;
	sta[top++] = cur;
	for(int i = head[cur]; ~i; i = nex[i])
		if(!dfn[ver[i]]) {
			tarjan(ver[i]);
			low[cur] = min(low[cur], low[ver[i]]);
		} else if(!co[ver[i]]) {
			low[cur] = min(low[cur], dfn[ver[i]]);
		}
	if(dfn[cur] == low[cur]) {
		while(sta[--top] != cur) {
			co[sta[top]] = col;
			sum[col] += a[sta[top]];
		}
		sum[col] += a[cur];
		co[cur] = col++;
	}
} 

int f[N];

int main() {
	memset(head, -1, sizeof(head));
	int n, m, u, v, ans = 0;
	scanf(&quot;%d %d&quot;, &amp;n, &amp;m);
	for(int i = 1; i &lt;= n; ++i) scanf(&quot;%d&quot;, a + i);
	for(int i = 1; i &lt;= m; ++i) {
		scanf(&quot;%d %d&quot;, &amp;u, &amp;v);
		addedge(u, v);
	}
	for(int i = 1; i &lt;= n; ++i) if(!dfn[i]) tarjan(i);
	for(int i = 0, end = tot; i &lt; end; ++i)
		if(co[my[i]] != co[ver[i]])
			addedge(co[my[i]] + n, co[ver[i]]);
	for(int i = col - 1; i; --i) {
		f[i] += sum[i];
		ans = max(f[i], ans);
		for(int j = head[i+n]; ~j; j = nex[j])
			f[ver[j]] = max(f[i], f[ver[j]]);
	}
	printf(&quot;%d\n&quot;, ans);
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[题解 [APIO2009]抢掠计划]]></title>
        <id>https://froldh.github.io/post/ti-jie-apio2009qiang-lue-ji-hua/</id>
        <link href="https://froldh.github.io/post/ti-jie-apio2009qiang-lue-ji-hua/">
        </link>
        <updated>2019-11-10T03:24:47.000Z</updated>
        <summary type="html"><![CDATA[<p>在有向图中,边又没啥限制,因而考虑缩点。缩点的同时记录该点内部有无酒吧以及该点的总钱数。</p>
]]></summary>
        <content type="html"><![CDATA[<p>在有向图中,边又没啥限制,因而考虑缩点。缩点的同时记录该点内部有无酒吧以及该点的总钱数。</p>
<!--more-->    
<p>缩完点之后,很自然地得到一个DAG。只要抢,就连同该DAG中的点一起包圆。<br>
然后我们可以在DAG上跑DP,根据tarjan的性质,缩点的编号是逆拓扑序的,因此只要按从起点所在点出发结点序递减的顺序递推即可,每次推到有酒吧的点更新答案。</p>
<pre><code class="language-cpp">#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;

using namespace std;

const int N = 567890;

int head[N&lt;&lt;1], ver[N&lt;&lt;1], nex[N&lt;&lt;1], my[N&lt;&lt;1], tot, n;
inline void addedge(int u, int v) {
	ver[tot] = v; nex[tot] = head[u]; my[tot] = u; head[u] = tot++;
}

int a[N], isba[N], s;

int dfn[N], low[N], co[N], bar[N], mon[N], sta[N], dfs_clock = 1, col = 1, top;
void tarjan(int cur) {
	dfn[cur] = low[cur] = dfs_clock++;
	sta[top++] = cur;
	for(int i = head[cur]; ~i; i = nex[i])
		if(!dfn[ver[i]]) {
			tarjan(ver[i]);
			low[cur] = min(low[cur], low[ver[i]]);
		} else if(!co[ver[i]]) {
			low[cur] = min(low[cur], dfn[ver[i]]);
		}
	if(dfn[cur] == low[cur]) {
		--top;
		while(sta[top] != cur) {
			if(isba[sta[top]]) bar[col] = 1;
			mon[col] += a[sta[top]];
			co[sta[top--]] = col;
		}
		co[cur] = col;
		mon[col] += a[cur];
		if(isba[cur]) bar[col] = 1;
		++col;
	}
}

int f[N], ans;

int main() {
	memset(head, -1, sizeof(head));
	int m, u, v, p;
	scanf(&quot;%d %d&quot;, &amp;n, &amp;m);
	for(int i = 1; i &lt;= m; ++i) {
		scanf(&quot;%d %d&quot;, &amp;u, &amp;v);
		addedge(u, v);
	}
	for(int i = 1; i &lt;= n; ++i) scanf(&quot;%d&quot;, a + i);
	scanf(&quot;%d %d&quot;, &amp;s, &amp;p);
	while(p--) scanf(&quot;%d&quot;, &amp;u), isba[u] = 1;
	for(int i = 1; i &lt;= n; ++i) if(!dfn[i]) tarjan(i);
	--col;
	for(int i = 0, end = tot; i &lt; end; ++i) 
		if(co[my[i]] != co[ver[i]])
			addedge(co[my[i]] + n, co[ver[i]]);
	for(int i = co[s]; i; --i) {
		f[i] += mon[i];
		if(bar[i]) ans = max(ans, f[i]);
		for(int j = head[i+n]; ~j; j = nex[j])
			f[ver[j]] = max(f[ver[j]], f[i]);
	}
	printf(&quot;%d\n&quot;, ans);
	return 0;
}

</code></pre>
]]></content>
    </entry>
</feed>